{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"prefect-kubernetes","text":""},{"location":"#welcome","title":"Welcome!","text":"<p><code>prefect-kubernetes</code> is a collection of Prefect tasks, flows, and blocks enabling orchestration, observation and management of Kubernetes resources.</p> <p>Jump to examples.</p>"},{"location":"#resources","title":"Resources","text":"<p>For more tips on how to use tasks and flows in a Collection, check out Using Collections!</p>"},{"location":"#installation","title":"Installation","text":"<p>Install <code>prefect-kubernetes</code> with <code>pip</code>: <pre><code> pip install prefect-kubernetes\n ```\n\nRequires an installation of Python 3.7+.\n\nWe recommend using a Python virtual environment manager such as pipenv, conda or virtualenv.\n\nThese tasks are designed to work with Prefect 2. For more information about how to use Prefect, please refer to the [Prefect documentation](https://docs.prefect.io/).\n\nThen, to register [blocks](https://docs.prefect.io/ui/blocks/) on Prefect Cloud:\n\n```bash\nprefect block register -m prefect_kubernetes\n</code></pre></p> <p>Note, to use the <code>load</code> method on Blocks, you must already have a block document saved through code or saved through the UI.</p>"},{"location":"#example-usage","title":"Example Usage","text":""},{"location":"#use-with_options-to-customize-options-on-any-existing-task-or-flow","title":"Use <code>with_options</code> to customize options on any existing task or flow","text":"<pre><code>from prefect_kubernetes.flows import run_namespaced_job\n\ncustomized_run_namespaced_job = run_namespaced_job.with_options(\n    name=\"My flow running a Kubernetes Job\",\n    retries=2,\n    retry_delay_seconds=10,\n) # this is now a new flow object that can be called\n</code></pre> <p>For more tips on how to use tasks and flows in a Collection, check out Using Collections!</p>"},{"location":"#specify-and-run-a-kubernetes-job-from-a-yaml-file","title":"Specify and run a Kubernetes Job from a yaml file","text":"<pre><code>from prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.flows import run_namespaced_job # this is a flow\nfrom prefect_kubernetes.jobs import KubernetesJob\n\nk8s_creds = KubernetesCredentials.load(\"k8s-creds\")\n\njob = KubernetesJob.from_yaml_file( # or create in the UI with a dict manifest\n    credentials=k8s_creds,\n    manifest_path=\"path/to/job.yaml\",\n)\n\njob.save(\"my-k8s-job\", overwrite=True)\n\nif __name__ == \"__main__\":\n    # run the flow\n    run_namespaced_job(job)\n</code></pre>"},{"location":"#generate-a-resource-specific-client-from-kubernetesclusterconfig","title":"Generate a resource-specific client from <code>KubernetesClusterConfig</code>","text":"<pre><code># with minikube / docker desktop &amp; a valid ~/.kube/config this should ~just work~\nfrom prefect.blocks.kubernetes import KubernetesClusterConfig\nfrom prefect_kubernetes.credentials import KubernetesCredentials\n\nk8s_config = KubernetesClusterConfig.from_file('~/.kube/config')\n\nk8s_credentials = KubernetesCredentials(cluster_config=k8s_config)\n\nwith k8s_credentials.get_client(\"core\") as v1_core_client:\n    for namespace in v1_core_client.list_namespace().items:\n        print(namespace.metadata.name)\n</code></pre>"},{"location":"#list-jobs-in-a-specific-namespace","title":"List jobs in a specific namespace","text":"<pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.jobs import list_namespaced_job\n\n@flow\ndef kubernetes_orchestrator():\n    v1_job_list = list_namespaced_job(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        namespace=\"my-namespace\",\n    )\n</code></pre>"},{"location":"#patch-an-existing-deployment","title":"Patch an existing deployment","text":"<pre><code>from kubernetes.client.models import V1Deployment\n\nfrom prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.deployments import patch_namespaced_deployment\nfrom prefect_kubernetes.utilities import convert_manifest_to_model\n\n@flow\ndef kubernetes_orchestrator():\n\n    v1_deployment_updates = convert_manifest_to_model(\n        manifest=\"path/to/manifest.yaml\",\n        v1_model_name=\"V1Deployment\",\n    )\n\n    v1_deployment = patch_namespaced_deployment(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        deployment_name=\"my-deployment\",\n        deployment_updates=v1_deployment_updates,\n        namespace=\"my-namespace\"\n    )\n</code></pre>"},{"location":"#feedback","title":"Feedback","text":"<p>If you encounter any bugs while using <code>prefect-kubernetes</code>, feel free to open an issue in the prefect-kubernetes repository.</p> <p>If you have any questions or issues while using <code>prefect-kubernetes</code>, you can find help in either the Prefect Discourse forum or the Prefect Slack community.</p> <p>Feel free to star or watch <code>prefect-kubernetes</code> for updates too!</p>"},{"location":"#contributing","title":"Contributing","text":"<p>If you'd like to help contribute to fix an issue or add a feature to <code>prefect-kubernetes</code>, please propose changes through a pull request from a fork of the repository.</p> <p>Here are the steps:</p> <ol> <li>Fork the repository</li> <li>Clone the forked repository</li> <li>Install the repository and its dependencies: <pre><code> pip install -e \".[dev]\"\n</code></pre></li> <li>Make desired changes</li> <li>Add tests</li> <li>Insert an entry to CHANGELOG.md</li> <li>Install <code>pre-commit</code> to perform quality checks prior to commit: <code>pre-commit install</code></li> <li><code>git commit</code>, <code>git push</code>, and create a pull request</li> </ol>"},{"location":"blocks_catalog/","title":"Blocks catalog","text":"<p>Below is a list of Blocks available for registration in <code>prefect-kubernetes</code>.</p> <p>To register blocks in this module to view and edit them on Prefect Cloud, first install the required packages, then <pre><code>prefect block register -m prefect_kubernetes\n</code></pre> Note, to use the <code>load</code> method on Blocks, you must already have a block document saved through code or saved through the UI.</p>"},{"location":"blocks_catalog/#credentials-module","title":"Credentials Module","text":"<p>KubernetesCredentials</p> <p>Credentials block for generating configured Kubernetes API clients.</p> <p>To load the KubernetesCredentials: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\n\n@flow\ndef my_flow():\n    my_block = KubernetesCredentials.load(\"MY_BLOCK_NAME\")\n\nmy_flow()\n</code></pre> For additional examples, check out the Credentials Module under Examples Catalog.</p>"},{"location":"blocks_catalog/#jobs-module","title":"Jobs Module","text":"<p>KubernetesJob</p> <p>A block representing a Kubernetes job configuration.</p> <p>To load the KubernetesJob: <pre><code>from prefect import flow\nfrom prefect_kubernetes.jobs import KubernetesJob\n\n@flow\ndef my_flow():\n    my_block = KubernetesJob.load(\"MY_BLOCK_NAME\")\n\nmy_flow()\n</code></pre> For additional examples, check out the Jobs Module under Examples Catalog.</p>"},{"location":"credentials/","title":"Credentials","text":""},{"location":"credentials/#prefect_kubernetes.credentials","title":"<code>prefect_kubernetes.credentials</code>","text":"<p>Module for defining Kubernetes credential handling and client generation.</p>"},{"location":"credentials/#prefect_kubernetes.credentials-classes","title":"Classes","text":""},{"location":"credentials/#prefect_kubernetes.credentials.KubernetesCredentials","title":"<code>KubernetesCredentials</code>","text":"<p>         Bases: <code>Block</code></p> <p>Credentials block for generating configured Kubernetes API clients.</p> <p>Attributes:</p> Name Type Description <code>cluster_config</code> <code>Optional[KubernetesClusterConfig]</code> <p>A <code>KubernetesClusterConfig</code> block holding a JSON kube config for a specific kubernetes context.</p> Example <p>Load stored Kubernetes credentials: <pre><code>from prefect_kubernetes.credentials import KubernetesCredentials\n\nkubernetes_credentials = KubernetesCredentials.load(\"BLOCK_NAME\")\n</code></pre></p> Source code in <code>prefect_kubernetes/credentials.py</code> <pre><code>class KubernetesCredentials(Block):\n\"\"\"Credentials block for generating configured Kubernetes API clients.\n\n    Attributes:\n        cluster_config: A `KubernetesClusterConfig` block holding a JSON kube\n            config for a specific kubernetes context.\n\n    Example:\n        Load stored Kubernetes credentials:\n        ```python\n        from prefect_kubernetes.credentials import KubernetesCredentials\n\n        kubernetes_credentials = KubernetesCredentials.load(\"BLOCK_NAME\")\n        ```\n    \"\"\"\n\n    _block_type_name = \"Kubernetes Credentials\"\n    _logo_url = \"https://images.ctfassets.net/zscdif0zqppk/oYuHjIbc26oilfQSEMjRv/a61f5f6ef406eead2df5231835b4c4c2/logo.png?h=250\"  # noqa\n    _documentation_url = \"https://prefecthq.github.io/prefect-kubernetes/credentials/#prefect_kubernetes.credentials.KubernetesCredentials\"  # noqa\n\n    cluster_config: Optional[KubernetesClusterConfig] = None\n\n    @contextmanager\n    def get_client(\n        self,\n        client_type: Literal[\"apps\", \"batch\", \"core\", \"custom_objects\"],\n        configuration: Optional[Configuration] = None,\n    ) -&gt; Generator[KubernetesClient, None, None]:\n\"\"\"Convenience method for retrieving a Kubernetes API client for deployment resources.\n\n        Args:\n            client_type: The resource-specific type of Kubernetes client to retrieve.\n\n        Yields:\n            An authenticated, resource-specific Kubernetes API client.\n\n        Example:\n            ```python\n            from prefect_kubernetes.credentials import KubernetesCredentials\n\n            with KubernetesCredentials.get_client(\"core\") as core_v1_client:\n                for pod in core_v1_client.list_namespaced_pod():\n                    print(pod.metadata.name)\n            ```\n        \"\"\"\n        client_config = configuration or Configuration()\n\n        with ApiClient(configuration=client_config) as generic_client:\n            try:\n                yield self.get_resource_specific_client(client_type)\n            finally:\n                generic_client.rest_client.pool_manager.clear()\n\n    def get_resource_specific_client(\n        self,\n        client_type: str,\n    ) -&gt; Union[AppsV1Api, BatchV1Api, CoreV1Api]:\n\"\"\"\n        Utility function for configuring a generic Kubernetes client.\n        It will attempt to connect to a Kubernetes cluster in three steps with\n        the first successful connection attempt becoming the mode of communication with\n        a cluster:\n\n        1. It will first attempt to use a `KubernetesCredentials` block's\n        `cluster_config` to configure a client using\n        `KubernetesClusterConfig.configure_client`.\n\n        2. Attempt in-cluster connection (will only work when running on a pod).\n\n        3. Attempt out-of-cluster connection using the default location for a\n        kube config file.\n\n        Args:\n            client_type: The Kubernetes API client type for interacting with specific\n                Kubernetes resources.\n\n        Returns:\n            KubernetesClient: An authenticated, resource-specific Kubernetes Client.\n\n        Raises:\n            ValueError: If `client_type` is not a valid Kubernetes API client type.\n        \"\"\"\n\n        if self.cluster_config:\n            self.cluster_config.configure_client()\n        else:\n            try:\n                kube_config.load_incluster_config()\n            except ConfigException:\n                kube_config.load_kube_config()\n\n        try:\n            return K8S_CLIENT_TYPES[client_type]()\n        except KeyError:\n            raise ValueError(\n                f\"Invalid client type provided '{client_type}'.\"\n                f\" Must be one of {listrepr(K8S_CLIENT_TYPES.keys())}.\"\n            )\n</code></pre>"},{"location":"credentials/#prefect_kubernetes.credentials.KubernetesCredentials-functions","title":"Functions","text":""},{"location":"credentials/#prefect_kubernetes.credentials.KubernetesCredentials.get_client","title":"<code>get_client</code>","text":"<p>Convenience method for retrieving a Kubernetes API client for deployment resources.</p> <p>Parameters:</p> Name Type Description Default <code>client_type</code> <code>Literal['apps', 'batch', 'core', 'custom_objects']</code> <p>The resource-specific type of Kubernetes client to retrieve.</p> required <p>Yields:</p> Type Description <code>KubernetesClient</code> <p>An authenticated, resource-specific Kubernetes API client.</p> Example <pre><code>from prefect_kubernetes.credentials import KubernetesCredentials\n\nwith KubernetesCredentials.get_client(\"core\") as core_v1_client:\n    for pod in core_v1_client.list_namespaced_pod():\n        print(pod.metadata.name)\n</code></pre> Source code in <code>prefect_kubernetes/credentials.py</code> <pre><code>@contextmanager\ndef get_client(\n    self,\n    client_type: Literal[\"apps\", \"batch\", \"core\", \"custom_objects\"],\n    configuration: Optional[Configuration] = None,\n) -&gt; Generator[KubernetesClient, None, None]:\n\"\"\"Convenience method for retrieving a Kubernetes API client for deployment resources.\n\n    Args:\n        client_type: The resource-specific type of Kubernetes client to retrieve.\n\n    Yields:\n        An authenticated, resource-specific Kubernetes API client.\n\n    Example:\n        ```python\n        from prefect_kubernetes.credentials import KubernetesCredentials\n\n        with KubernetesCredentials.get_client(\"core\") as core_v1_client:\n            for pod in core_v1_client.list_namespaced_pod():\n                print(pod.metadata.name)\n        ```\n    \"\"\"\n    client_config = configuration or Configuration()\n\n    with ApiClient(configuration=client_config) as generic_client:\n        try:\n            yield self.get_resource_specific_client(client_type)\n        finally:\n            generic_client.rest_client.pool_manager.clear()\n</code></pre>"},{"location":"credentials/#prefect_kubernetes.credentials.KubernetesCredentials.get_resource_specific_client","title":"<code>get_resource_specific_client</code>","text":"<p>Utility function for configuring a generic Kubernetes client. It will attempt to connect to a Kubernetes cluster in three steps with the first successful connection attempt becoming the mode of communication with a cluster:</p> <ol> <li> <p>It will first attempt to use a <code>KubernetesCredentials</code> block's <code>cluster_config</code> to configure a client using <code>KubernetesClusterConfig.configure_client</code>.</p> </li> <li> <p>Attempt in-cluster connection (will only work when running on a pod).</p> </li> <li> <p>Attempt out-of-cluster connection using the default location for a kube config file.</p> </li> </ol> <p>Parameters:</p> Name Type Description Default <code>client_type</code> <code>str</code> <p>The Kubernetes API client type for interacting with specific Kubernetes resources.</p> required <p>Returns:</p> Name Type Description <code>KubernetesClient</code> <code>Union[AppsV1Api, BatchV1Api, CoreV1Api]</code> <p>An authenticated, resource-specific Kubernetes Client.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>client_type</code> is not a valid Kubernetes API client type.</p> Source code in <code>prefect_kubernetes/credentials.py</code> <pre><code>def get_resource_specific_client(\n    self,\n    client_type: str,\n) -&gt; Union[AppsV1Api, BatchV1Api, CoreV1Api]:\n\"\"\"\n    Utility function for configuring a generic Kubernetes client.\n    It will attempt to connect to a Kubernetes cluster in three steps with\n    the first successful connection attempt becoming the mode of communication with\n    a cluster:\n\n    1. It will first attempt to use a `KubernetesCredentials` block's\n    `cluster_config` to configure a client using\n    `KubernetesClusterConfig.configure_client`.\n\n    2. Attempt in-cluster connection (will only work when running on a pod).\n\n    3. Attempt out-of-cluster connection using the default location for a\n    kube config file.\n\n    Args:\n        client_type: The Kubernetes API client type for interacting with specific\n            Kubernetes resources.\n\n    Returns:\n        KubernetesClient: An authenticated, resource-specific Kubernetes Client.\n\n    Raises:\n        ValueError: If `client_type` is not a valid Kubernetes API client type.\n    \"\"\"\n\n    if self.cluster_config:\n        self.cluster_config.configure_client()\n    else:\n        try:\n            kube_config.load_incluster_config()\n        except ConfigException:\n            kube_config.load_kube_config()\n\n    try:\n        return K8S_CLIENT_TYPES[client_type]()\n    except KeyError:\n        raise ValueError(\n            f\"Invalid client type provided '{client_type}'.\"\n            f\" Must be one of {listrepr(K8S_CLIENT_TYPES.keys())}.\"\n        )\n</code></pre>"},{"location":"custom_objects/","title":"Custom Objects","text":""},{"location":"custom_objects/#prefect_kubernetes.custom_objects","title":"<code>prefect_kubernetes.custom_objects</code>","text":""},{"location":"custom_objects/#prefect_kubernetes.custom_objects-classes","title":"Classes","text":""},{"location":"custom_objects/#prefect_kubernetes.custom_objects-functions","title":"Functions","text":""},{"location":"custom_objects/#prefect_kubernetes.custom_objects.create_namespaced_custom_object","title":"<code>create_namespaced_custom_object</code>  <code>async</code>","text":"<p>Task for creating a namespaced custom object.</p> <p>Parameters:</p> Name Type Description Default <code>kubernetes_credentials</code> <code>KubernetesCredentials</code> <p><code>KubernetesCredentials</code> block holding authentication needed to generate the required API client.</p> required <code>group</code> <code>str</code> <p>The custom resource object's group</p> required <code>version</code> <code>str</code> <p>The custom resource object's version</p> required <code>plural</code> <code>str</code> <p>The custom resource object's plural</p> required <code>body</code> <code>Dict[str, Any]</code> <p>A Dict containing the custom resource object's specification.</p> required <code>namespace</code> <code>Optional[str]</code> <p>The Kubernetes namespace to create the custom object in.</p> <code>'default'</code> <code>**kube_kwargs</code> <code>Dict[str, Any]</code> <p>Optional extra keyword arguments to pass to the Kubernetes API (e.g. <code>{\"pretty\": \"...\", \"dry_run\": \"...\"}</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>object</code> <p>object containing the custom resource created by this task.</p> Example <p>Create a custom object in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.custom_objects import create_namespaced_custom_object\n\n@flow\ndef kubernetes_orchestrator():\n    custom_object_metadata = create_namespaced_custom_object(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        group=\"crd-group\",\n        version=\"crd-version\",\n        plural=\"crd-plural\",\n        body={\n            'api': 'crd-version',\n            'kind': 'crd-kind',\n            'metadata': {\n                'name': 'crd-name',\n            },\n        },\n    )\n</code></pre></p> Source code in <code>prefect_kubernetes/custom_objects.py</code> <pre><code>@task\nasync def create_namespaced_custom_object(\n    kubernetes_credentials: KubernetesCredentials,\n    group: str,\n    version: str,\n    plural: str,\n    body: Dict[str, Any],\n    namespace: Optional[str] = \"default\",\n    **kube_kwargs: Dict[str, Any],\n) -&gt; object:\n\"\"\"Task for creating a namespaced custom object.\n\n    Args:\n        kubernetes_credentials: `KubernetesCredentials` block\n            holding authentication needed to generate the required API client.\n        group: The custom resource object's group\n        version: The custom resource object's version\n        plural: The custom resource object's plural\n        body: A Dict containing the custom resource object's specification.\n        namespace: The Kubernetes namespace to create the custom object in.\n        **kube_kwargs: Optional extra keyword arguments to pass to the\n            Kubernetes API (e.g. `{\"pretty\": \"...\", \"dry_run\": \"...\"}`).\n\n    Returns:\n        object containing the custom resource created by this task.\n\n    Example:\n        Create a custom object in the default namespace:\n        ```python\n        from prefect import flow\n        from prefect_kubernetes.credentials import KubernetesCredentials\n        from prefect_kubernetes.custom_objects import create_namespaced_custom_object\n\n        @flow\n        def kubernetes_orchestrator():\n            custom_object_metadata = create_namespaced_custom_object(\n                kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n                group=\"crd-group\",\n                version=\"crd-version\",\n                plural=\"crd-plural\",\n                body={\n                    'api': 'crd-version',\n                    'kind': 'crd-kind',\n                    'metadata': {\n                        'name': 'crd-name',\n                    },\n                },\n            )\n        ```\n    \"\"\"\n    with kubernetes_credentials.get_client(\"custom_objects\") as custom_objects_client:\n        return await run_sync_in_worker_thread(\n            custom_objects_client.create_namespaced_custom_object,\n            group=group,\n            version=version,\n            plural=plural,\n            body=body,\n            namespace=namespace,\n            **kube_kwargs,\n        )\n</code></pre>"},{"location":"custom_objects/#prefect_kubernetes.custom_objects.delete_namespaced_custom_object","title":"<code>delete_namespaced_custom_object</code>  <code>async</code>","text":"<p>Task for deleting a namespaced custom object.</p> <p>Parameters:</p> Name Type Description Default <code>kubernetes_credentials</code> <code>KubernetesCredentials</code> <p><code>KubernetesCredentials</code> block holding authentication needed to generate the required API client.</p> required <code>group</code> <code>str</code> <p>The custom resource object's group</p> required <code>version</code> <code>str</code> <p>The custom resource object's version</p> required <code>plural</code> <code>str</code> <p>The custom resource object's plural</p> required <code>name</code> <code>str</code> <p>The name of a custom object to delete.</p> required <code>namespace</code> <code>Optional[str]</code> <p>The Kubernetes namespace to create this custom object in.</p> <code>'default'</code> <code>**kube_kwargs</code> <code>Dict[str, Any]</code> <p>Optional extra keyword arguments to pass to the Kubernetes API (e.g. <code>{\"pretty\": \"...\", \"dry_run\": \"...\"}</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>object</code> <p>object containing the custom resource deleted by this task.</p> Example <p>Delete \"my-custom-object\" in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.custom_objects import delete_namespaced_custom_object\n\n@flow\ndef kubernetes_orchestrator():\n    custom_object_metadata = delete_namespaced_custom_object(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        group=\"crd-group\",\n        version=\"crd-version\",\n        plural=\"crd-plural\",\n        name=\"my-custom-object\",\n    )\n</code></pre></p> Source code in <code>prefect_kubernetes/custom_objects.py</code> <pre><code>@task\nasync def delete_namespaced_custom_object(\n    kubernetes_credentials: KubernetesCredentials,\n    group: str,\n    version: str,\n    plural: str,\n    name: str,\n    namespace: Optional[str] = \"default\",\n    **kube_kwargs: Dict[str, Any],\n) -&gt; object:\n\"\"\"Task for deleting a namespaced custom object.\n\n    Args:\n        kubernetes_credentials: `KubernetesCredentials` block\n            holding authentication needed to generate the required API client.\n        group: The custom resource object's group\n        version: The custom resource object's version\n        plural: The custom resource object's plural\n        name: The name of a custom object to delete.\n        namespace: The Kubernetes namespace to create this custom object in.\n        **kube_kwargs: Optional extra keyword arguments to pass to the\n            Kubernetes API (e.g. `{\"pretty\": \"...\", \"dry_run\": \"...\"}`).\n\n\n    Returns:\n        object containing the custom resource deleted by this task.\n\n    Example:\n        Delete \"my-custom-object\" in the default namespace:\n        ```python\n        from prefect import flow\n        from prefect_kubernetes.credentials import KubernetesCredentials\n        from prefect_kubernetes.custom_objects import delete_namespaced_custom_object\n\n        @flow\n        def kubernetes_orchestrator():\n            custom_object_metadata = delete_namespaced_custom_object(\n                kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n                group=\"crd-group\",\n                version=\"crd-version\",\n                plural=\"crd-plural\",\n                name=\"my-custom-object\",\n            )\n        ```\n    \"\"\"\n\n    with kubernetes_credentials.get_client(\"custom_objects\") as custom_objects_client:\n        return await run_sync_in_worker_thread(\n            custom_objects_client.delete_namespaced_custom_object,\n            group=group,\n            version=version,\n            plural=plural,\n            name=name,\n            namespace=namespace,\n            **kube_kwargs,\n        )\n</code></pre>"},{"location":"custom_objects/#prefect_kubernetes.custom_objects.get_namespaced_custom_object","title":"<code>get_namespaced_custom_object</code>  <code>async</code>","text":"<p>Task for reading a namespaced Kubernetes custom object.</p> <p>Parameters:</p> Name Type Description Default <code>kubernetes_credentials</code> <code>KubernetesCredentials</code> <p><code>KubernetesCredentials</code> block holding authentication needed to generate the required API client.</p> required <code>group</code> <code>str</code> <p>The custom resource object's group</p> required <code>version</code> <code>str</code> <p>The custom resource object's version</p> required <code>plural</code> <code>str</code> <p>The custom resource object's plural</p> required <code>name</code> <code>str</code> <p>The name of a custom object to read.</p> required <code>namespace</code> <code>Optional[str]</code> <p>The Kubernetes namespace the custom resource is in.</p> <code>'default'</code> <code>**kube_kwargs</code> <code>Dict[str, Any]</code> <p>Optional extra keyword arguments to pass to the Kubernetes API (e.g. <code>{\"pretty\": \"...\", \"dry_run\": \"...\"}</code>).</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if <code>name</code> is <code>None</code>.</p> <p>Returns:</p> Type Description <code>object</code> <p>object containing the custom resource specification.</p> Example <p>Read \"my-custom-object\" in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.custom_objects import get_namespaced_custom_object\n\n@flow\ndef kubernetes_orchestrator():\n    custom_object_metadata = get_namespaced_custom_object(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        group=\"crd-group\",\n        version=\"crd-version\",\n        plural=\"crd-plural\",\n        name=\"my-custom-object\",\n    )\n</code></pre></p> Source code in <code>prefect_kubernetes/custom_objects.py</code> <pre><code>@task\nasync def get_namespaced_custom_object(\n    kubernetes_credentials: KubernetesCredentials,\n    group: str,\n    version: str,\n    plural: str,\n    name: str,\n    namespace: Optional[str] = \"default\",\n    **kube_kwargs: Dict[str, Any],\n) -&gt; object:\n\"\"\"Task for reading a namespaced Kubernetes custom object.\n\n    Args:\n        kubernetes_credentials: `KubernetesCredentials` block\n            holding authentication needed to generate the required API client.\n        group: The custom resource object's group\n        version: The custom resource object's version\n        plural: The custom resource object's plural\n        name: The name of a custom object to read.\n        namespace: The Kubernetes namespace the custom resource is in.\n        **kube_kwargs: Optional extra keyword arguments to pass to the\n            Kubernetes API (e.g. `{\"pretty\": \"...\", \"dry_run\": \"...\"}`).\n\n    Raises:\n        ValueError: if `name` is `None`.\n\n    Returns:\n        object containing the custom resource specification.\n\n    Example:\n        Read \"my-custom-object\" in the default namespace:\n        ```python\n        from prefect import flow\n        from prefect_kubernetes.credentials import KubernetesCredentials\n        from prefect_kubernetes.custom_objects import get_namespaced_custom_object\n\n        @flow\n        def kubernetes_orchestrator():\n            custom_object_metadata = get_namespaced_custom_object(\n                kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n                group=\"crd-group\",\n                version=\"crd-version\",\n                plural=\"crd-plural\",\n                name=\"my-custom-object\",\n            )\n        ```\n    \"\"\"\n    with kubernetes_credentials.get_client(\"custom_objects\") as custom_objects_client:\n        return await run_sync_in_worker_thread(\n            custom_objects_client.get_namespaced_custom_object,\n            group=group,\n            version=version,\n            plural=plural,\n            name=name,\n            namespace=namespace,\n            **kube_kwargs,\n        )\n</code></pre>"},{"location":"custom_objects/#prefect_kubernetes.custom_objects.get_namespaced_custom_object_status","title":"<code>get_namespaced_custom_object_status</code>  <code>async</code>","text":"<p>Task for fetching status of a namespaced custom object.</p> <p>Parameters:</p> Name Type Description Default <code>kubernetes_credentials</code> <code>KubernetesCredentials</code> <p><code>KubernetesCredentials</code> block holding authentication needed to generate the required API client.</p> required <code>group</code> <code>str</code> <p>The custom resource object's group</p> required <code>version</code> <code>str</code> <p>The custom resource object's version</p> required <code>plural</code> <code>str</code> <p>The custom resource object's plural</p> required <code>name</code> <code>str</code> <p>The name of a custom object to read.</p> required <code>namespace</code> <code>str</code> <p>The Kubernetes namespace the custom resource is in.</p> <code>'default'</code> <code>**kube_kwargs</code> <code>Dict[str, Any]</code> <p>Optional extra keyword arguments to pass to the Kubernetes API (e.g. <code>{\"pretty\": \"...\", \"dry_run\": \"...\"}</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>object</code> <p>object containing the custom-object specification with status.</p> Example <p>Fetch status of \"my-custom-object\" in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.custom_objects import (\n    get_namespaced_custom_object_status,\n)\n\n@flow\ndef kubernetes_orchestrator():\n    custom_object_metadata = get_namespaced_custom_object_status(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        group=\"crd-group\",\n        version=\"crd-version\",\n        plural=\"crd-plural\",\n        name=\"my-custom-object\",\n    )\n</code></pre></p> Source code in <code>prefect_kubernetes/custom_objects.py</code> <pre><code>@task\nasync def get_namespaced_custom_object_status(\n    kubernetes_credentials: KubernetesCredentials,\n    group: str,\n    version: str,\n    plural: str,\n    name: str,\n    namespace: str = \"default\",\n    **kube_kwargs: Dict[str, Any],\n) -&gt; object:\n\"\"\"Task for fetching status of a namespaced custom object.\n\n    Args:\n        kubernetes_credentials: `KubernetesCredentials` block\n            holding authentication needed to generate the required API client.\n        group: The custom resource object's group\n        version: The custom resource object's version\n        plural: The custom resource object's plural\n        name: The name of a custom object to read.\n        namespace: The Kubernetes namespace the custom resource is in.\n        **kube_kwargs: Optional extra keyword arguments to pass to the\n            Kubernetes API (e.g. `{\"pretty\": \"...\", \"dry_run\": \"...\"}`).\n\n    Returns:\n        object containing the custom-object specification with status.\n\n    Example:\n        Fetch status of \"my-custom-object\" in the default namespace:\n        ```python\n        from prefect import flow\n        from prefect_kubernetes.credentials import KubernetesCredentials\n        from prefect_kubernetes.custom_objects import (\n            get_namespaced_custom_object_status,\n        )\n\n        @flow\n        def kubernetes_orchestrator():\n            custom_object_metadata = get_namespaced_custom_object_status(\n                kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n                group=\"crd-group\",\n                version=\"crd-version\",\n                plural=\"crd-plural\",\n                name=\"my-custom-object\",\n            )\n        ```\n    \"\"\"\n    with kubernetes_credentials.get_client(\"custom_objects\") as custom_objects_client:\n        return await run_sync_in_worker_thread(\n            custom_objects_client.get_namespaced_custom_object_status,\n            group=group,\n            version=version,\n            plural=plural,\n            name=name,\n            namespace=namespace,\n            **kube_kwargs,\n        )\n</code></pre>"},{"location":"custom_objects/#prefect_kubernetes.custom_objects.list_namespaced_custom_object","title":"<code>list_namespaced_custom_object</code>  <code>async</code>","text":"<p>Task for listing namespaced custom objects.</p> <p>Parameters:</p> Name Type Description Default <code>kubernetes_credentials</code> <code>KubernetesCredentials</code> <p><code>KubernetesCredentials</code> block holding authentication needed to generate the required API client.</p> required <code>group</code> <code>str</code> <p>The custom resource object's group</p> required <code>version</code> <code>str</code> <p>The custom resource object's version</p> required <code>plural</code> <code>str</code> <p>The custom resource object's plural</p> required <code>namespace</code> <code>str</code> <p>The Kubernetes namespace to list custom resources for.</p> <code>'default'</code> <code>**kube_kwargs</code> <code>Dict[str, Any]</code> <p>Optional extra keyword arguments to pass to the Kubernetes API (e.g. <code>{\"pretty\": \"...\", \"dry_run\": \"...\"}</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>object</code> <p>object containing a list of custom resources.</p> Example <p>List custom resources in \"my-namespace\": <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.custom_objects import list_namespaced_custom_object\n\n@flow\ndef kubernetes_orchestrator():\n    namespaced_custom_objects_list = list_namespaced_custom_object(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        group=\"crd-group\",\n        version=\"crd-version\",\n        plural=\"crd-plural\",\n        namespace=\"my-namespace\",\n    )\n</code></pre></p> Source code in <code>prefect_kubernetes/custom_objects.py</code> <pre><code>@task\nasync def list_namespaced_custom_object(\n    kubernetes_credentials: KubernetesCredentials,\n    group: str,\n    version: str,\n    plural: str,\n    namespace: str = \"default\",\n    **kube_kwargs: Dict[str, Any],\n) -&gt; object:\n\"\"\"Task for listing namespaced custom objects.\n\n    Args:\n        kubernetes_credentials: `KubernetesCredentials` block\n            holding authentication needed to generate the required API client.\n        group: The custom resource object's group\n        version: The custom resource object's version\n        plural: The custom resource object's plural\n        namespace: The Kubernetes namespace to list custom resources for.\n        **kube_kwargs: Optional extra keyword arguments to pass to the\n            Kubernetes API (e.g. `{\"pretty\": \"...\", \"dry_run\": \"...\"}`).\n\n    Returns:\n        object containing a list of custom resources.\n\n    Example:\n        List custom resources in \"my-namespace\":\n        ```python\n        from prefect import flow\n        from prefect_kubernetes.credentials import KubernetesCredentials\n        from prefect_kubernetes.custom_objects import list_namespaced_custom_object\n\n        @flow\n        def kubernetes_orchestrator():\n            namespaced_custom_objects_list = list_namespaced_custom_object(\n                kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n                group=\"crd-group\",\n                version=\"crd-version\",\n                plural=\"crd-plural\",\n                namespace=\"my-namespace\",\n            )\n        ```\n    \"\"\"\n    with kubernetes_credentials.get_client(\"custom_objects\") as custom_objects_client:\n        return await run_sync_in_worker_thread(\n            custom_objects_client.list_namespaced_custom_object,\n            group=group,\n            version=version,\n            plural=plural,\n            namespace=namespace,\n            **kube_kwargs,\n        )\n</code></pre>"},{"location":"custom_objects/#prefect_kubernetes.custom_objects.patch_namespaced_custom_object","title":"<code>patch_namespaced_custom_object</code>  <code>async</code>","text":"<p>Task for patching a namespaced custom resource.</p> <p>Parameters:</p> Name Type Description Default <code>kubernetes_credentials</code> <code>KubernetesCredentials</code> <p>KubernetesCredentials block holding authentication needed to generate the required API client.</p> required <code>group</code> <code>str</code> <p>The custom resource object's group</p> required <code>version</code> <code>str</code> <p>The custom resource object's version</p> required <code>plural</code> <code>str</code> <p>The custom resource object's plural</p> required <code>name</code> <code>str</code> <p>The name of a custom object to patch.</p> required <code>body</code> <code>Dict[str, Any]</code> <p>A Dict containing the custom resource object's patch.</p> required <code>namespace</code> <code>str</code> <p>The custom resource's Kubernetes namespace.</p> <code>'default'</code> <code>**kube_kwargs</code> <code>Dict[str, Any]</code> <p>Optional extra keyword arguments to pass to the Kubernetes API (e.g. <code>{\"pretty\": \"...\", \"dry_run\": \"...\"}</code>).</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if <code>body</code> is <code>None</code>.</p> <p>Returns:</p> Type Description <code>object</code> <p>object containing the custom resource specification</p> <code>object</code> <p>after the patch gets applied.</p> Example <p>Patch \"my-custom-object\" in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.custom_objects import (\n    patch_namespaced_custom_object,\n)\n\n@flow\ndef kubernetes_orchestrator():\n    custom_object_metadata = patch_namespaced_custom_object(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        group=\"crd-group\",\n        version=\"crd-version\",\n        plural=\"crd-plural\",\n        name=\"my-custom-object\",\n        body={\n            'api': 'crd-version',\n            'kind': 'crd-kind',\n            'metadata': {\n                'name': 'my-custom-object',\n            },\n        },\n    )\n</code></pre></p> Source code in <code>prefect_kubernetes/custom_objects.py</code> <pre><code>@task\nasync def patch_namespaced_custom_object(\n    kubernetes_credentials: KubernetesCredentials,\n    group: str,\n    version: str,\n    plural: str,\n    name: str,\n    body: Dict[str, Any],\n    namespace: str = \"default\",\n    **kube_kwargs: Dict[str, Any],\n) -&gt; object:\n\"\"\"Task for patching a namespaced custom resource.\n\n    Args:\n        kubernetes_credentials: KubernetesCredentials block\n            holding authentication needed to generate the required API client.\n        group: The custom resource object's group\n        version: The custom resource object's version\n        plural: The custom resource object's plural\n        name: The name of a custom object to patch.\n        body: A Dict containing the custom resource object's patch.\n        namespace: The custom resource's Kubernetes namespace.\n        **kube_kwargs: Optional extra keyword arguments to pass to the\n            Kubernetes API (e.g. `{\"pretty\": \"...\", \"dry_run\": \"...\"}`).\n\n    Raises:\n        ValueError: if `body` is `None`.\n\n    Returns:\n        object containing the custom resource specification\n        after the patch gets applied.\n\n    Example:\n        Patch \"my-custom-object\" in the default namespace:\n        ```python\n        from prefect import flow\n        from prefect_kubernetes.credentials import KubernetesCredentials\n        from prefect_kubernetes.custom_objects import (\n            patch_namespaced_custom_object,\n        )\n\n        @flow\n        def kubernetes_orchestrator():\n            custom_object_metadata = patch_namespaced_custom_object(\n                kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n                group=\"crd-group\",\n                version=\"crd-version\",\n                plural=\"crd-plural\",\n                name=\"my-custom-object\",\n                body={\n                    'api': 'crd-version',\n                    'kind': 'crd-kind',\n                    'metadata': {\n                        'name': 'my-custom-object',\n                    },\n                },\n            )\n        ```\n    \"\"\"\n    with kubernetes_credentials.get_client(\"custom_objects\") as custom_objects_client:\n        return await run_sync_in_worker_thread(\n            custom_objects_client.patch_namespaced_custom_object,\n            group=group,\n            version=version,\n            plural=plural,\n            name=name,\n            body=body,\n            namespace=namespace,\n            **kube_kwargs,\n        )\n</code></pre>"},{"location":"custom_objects/#prefect_kubernetes.custom_objects.replace_namespaced_custom_object","title":"<code>replace_namespaced_custom_object</code>  <code>async</code>","text":"<p>Task for replacing a namespaced custom resource.</p> <p>Parameters:</p> Name Type Description Default <code>kubernetes_credentials</code> <code>KubernetesCredentials</code> <p>KubernetesCredentials block holding authentication needed to generate the required API client.</p> required <code>group</code> <code>str</code> <p>The custom resource object's group</p> required <code>version</code> <code>str</code> <p>The custom resource object's version</p> required <code>plural</code> <code>str</code> <p>The custom resource object's plural</p> required <code>name</code> <code>str</code> <p>The name of a custom object to replace.</p> required <code>body</code> <code>Dict[str, Any]</code> <p>A Dict containing the custom resource object's specification.</p> required <code>namespace</code> <code>str</code> <p>The custom resource's Kubernetes namespace.</p> <code>'default'</code> <code>**kube_kwargs</code> <code>Dict[str, Any]</code> <p>Optional extra keyword arguments to pass to the Kubernetes API (e.g. <code>{\"pretty\": \"...\", \"dry_run\": \"...\"}</code>).</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if <code>body</code> is <code>None</code>.</p> <p>Returns:</p> Type Description <code>object</code> <p>object containing the custom resource specification after the replacement.</p> Example <p>Replace \"my-custom-object\" in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.custom_objects import replace_namespaced_custom_object\n\n@flow\ndef kubernetes_orchestrator():\n    custom_object_metadata = replace_namespaced_custom_object(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        group=\"crd-group\",\n        version=\"crd-version\",\n        plural=\"crd-plural\",\n        name=\"my-custom-object\",\n        body={\n            'api': 'crd-version',\n            'kind': 'crd-kind',\n            'metadata': {\n                'name': 'my-custom-object',\n            },\n        },\n    )\n</code></pre></p> Source code in <code>prefect_kubernetes/custom_objects.py</code> <pre><code>@task\nasync def replace_namespaced_custom_object(\n    kubernetes_credentials: KubernetesCredentials,\n    group: str,\n    version: str,\n    plural: str,\n    name: str,\n    body: Dict[str, Any],\n    namespace: str = \"default\",\n    **kube_kwargs: Dict[str, Any],\n) -&gt; object:\n\"\"\"Task for replacing a namespaced custom resource.\n\n    Args:\n        kubernetes_credentials: KubernetesCredentials block\n            holding authentication needed to generate the required API client.\n        group: The custom resource object's group\n        version: The custom resource object's version\n        plural: The custom resource object's plural\n        name: The name of a custom object to replace.\n        body: A Dict containing the custom resource object's specification.\n        namespace: The custom resource's Kubernetes namespace.\n        **kube_kwargs: Optional extra keyword arguments to pass to the\n            Kubernetes API (e.g. `{\"pretty\": \"...\", \"dry_run\": \"...\"}`).\n\n    Raises:\n        ValueError: if `body` is `None`.\n\n    Returns:\n        object containing the custom resource specification after the replacement.\n\n    Example:\n        Replace \"my-custom-object\" in the default namespace:\n        ```python\n        from prefect import flow\n        from prefect_kubernetes.credentials import KubernetesCredentials\n        from prefect_kubernetes.custom_objects import replace_namespaced_custom_object\n\n        @flow\n        def kubernetes_orchestrator():\n            custom_object_metadata = replace_namespaced_custom_object(\n                kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n                group=\"crd-group\",\n                version=\"crd-version\",\n                plural=\"crd-plural\",\n                name=\"my-custom-object\",\n                body={\n                    'api': 'crd-version',\n                    'kind': 'crd-kind',\n                    'metadata': {\n                        'name': 'my-custom-object',\n                    },\n                },\n            )\n        ```\n    \"\"\"\n    with kubernetes_credentials.get_client(\"custom_objects\") as custom_objects_client:\n        return await run_sync_in_worker_thread(\n            custom_objects_client.replace_namespaced_custom_object,\n            group=group,\n            version=version,\n            plural=plural,\n            name=name,\n            body=body,\n            namespace=namespace,\n            **kube_kwargs,\n        )\n</code></pre>"},{"location":"deployments/","title":"Deployments","text":""},{"location":"deployments/#prefect_kubernetes.deployments","title":"<code>prefect_kubernetes.deployments</code>","text":"<p>Module for interacting with Kubernetes deployments from Prefect flows.</p>"},{"location":"deployments/#prefect_kubernetes.deployments-classes","title":"Classes","text":""},{"location":"deployments/#prefect_kubernetes.deployments-functions","title":"Functions","text":""},{"location":"deployments/#prefect_kubernetes.deployments.create_namespaced_deployment","title":"<code>create_namespaced_deployment</code>  <code>async</code>","text":"<p>Create a Kubernetes deployment in a given namespace.</p> <p>Parameters:</p> Name Type Description Default <code>kubernetes_credentials</code> <code>KubernetesCredentials</code> <p><code>KubernetesCredentials</code> block for creating authenticated Kubernetes API clients.</p> required <code>new_deployment</code> <code>V1Deployment</code> <p>A Kubernetes <code>V1Deployment</code> specification.</p> required <code>namespace</code> <code>Optional[str]</code> <p>The Kubernetes namespace to create this deployment in.</p> <code>'default'</code> <code>**kube_kwargs</code> <code>Dict[str, Any]</code> <p>Optional extra keyword arguments to pass to the Kubernetes API.</p> <code>{}</code> <p>Returns:</p> Type Description <code>V1Deployment</code> <p>A Kubernetes <code>V1Deployment</code> object.</p> Example <p>Create a deployment in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.deployments import create_namespaced_deployment\nfrom kubernetes.client.models import V1Deployment\n\n@flow\ndef kubernetes_orchestrator():\n    v1_deployment_metadata = create_namespaced_deployment(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        new_deployment=V1Deployment(metadata={\"name\": \"test-deployment\"}),\n    )\n</code></pre></p> Source code in <code>prefect_kubernetes/deployments.py</code> <pre><code>@task\nasync def create_namespaced_deployment(\n    kubernetes_credentials: KubernetesCredentials,\n    new_deployment: V1Deployment,\n    namespace: Optional[str] = \"default\",\n    **kube_kwargs: Dict[str, Any],\n) -&gt; V1Deployment:\n\"\"\"Create a Kubernetes deployment in a given namespace.\n\n    Args:\n        kubernetes_credentials: `KubernetesCredentials` block for creating\n            authenticated Kubernetes API clients.\n        new_deployment: A Kubernetes `V1Deployment` specification.\n        namespace: The Kubernetes namespace to create this deployment in.\n        **kube_kwargs: Optional extra keyword arguments to pass to the Kubernetes API.\n\n    Returns:\n        A Kubernetes `V1Deployment` object.\n\n    Example:\n        Create a deployment in the default namespace:\n        ```python\n        from prefect import flow\n        from prefect_kubernetes.credentials import KubernetesCredentials\n        from prefect_kubernetes.deployments import create_namespaced_deployment\n        from kubernetes.client.models import V1Deployment\n\n        @flow\n        def kubernetes_orchestrator():\n            v1_deployment_metadata = create_namespaced_deployment(\n                kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n                new_deployment=V1Deployment(metadata={\"name\": \"test-deployment\"}),\n            )\n        ```\n    \"\"\"\n    with kubernetes_credentials.get_client(\"core\") as core_v1_client:\n\n        return await run_sync_in_worker_thread(\n            core_v1_client.create_namespaced_deployment,\n            namespace=namespace,\n            body=new_deployment,\n            **kube_kwargs,\n        )\n</code></pre>"},{"location":"deployments/#prefect_kubernetes.deployments.delete_namespaced_deployment","title":"<code>delete_namespaced_deployment</code>  <code>async</code>","text":"<p>Delete a Kubernetes deployment in a given namespace.</p> <p>Parameters:</p> Name Type Description Default <code>kubernetes_credentials</code> <code>KubernetesCredentials</code> <p><code>KubernetesCredentials</code> block for creating authenticated Kubernetes API clients.</p> required <code>deployment_name</code> <code>str</code> <p>The name of the deployment to delete.</p> required <code>delete_options</code> <code>Optional[V1DeleteOptions]</code> <p>A Kubernetes <code>V1DeleteOptions</code> object.</p> <code>None</code> <code>namespace</code> <code>Optional[str]</code> <p>The Kubernetes namespace to delete this deployment from.</p> <code>'default'</code> <code>**kube_kwargs</code> <code>Dict[str, Any]</code> <p>Optional extra keyword arguments to pass to the Kubernetes API.</p> <code>{}</code> <p>Returns:</p> Type Description <code>V1Deployment</code> <p>A Kubernetes <code>V1Deployment</code> object.</p> Example <p>Delete a deployment in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.deployments import delete_namespaced_deployment\nfrom kubernetes.client.models import V1DeleteOptions\n\n@flow\ndef kubernetes_orchestrator():\n    v1_deployment_metadata = delete_namespaced_deployment(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        deployment_name=\"test-deployment\",\n        delete_options=V1DeleteOptions(grace_period_seconds=0),\n    )\n</code></pre></p> Source code in <code>prefect_kubernetes/deployments.py</code> <pre><code>@task\nasync def delete_namespaced_deployment(\n    kubernetes_credentials: KubernetesCredentials,\n    deployment_name: str,\n    delete_options: Optional[V1DeleteOptions] = None,\n    namespace: Optional[str] = \"default\",\n    **kube_kwargs: Dict[str, Any],\n) -&gt; V1Deployment:\n\"\"\"Delete a Kubernetes deployment in a given namespace.\n\n    Args:\n        kubernetes_credentials: `KubernetesCredentials` block for creating\n            authenticated Kubernetes API clients.\n        deployment_name: The name of the deployment to delete.\n        delete_options: A Kubernetes `V1DeleteOptions` object.\n        namespace: The Kubernetes namespace to delete this deployment from.\n        **kube_kwargs: Optional extra keyword arguments to pass to the Kubernetes API.\n\n    Returns:\n        A Kubernetes `V1Deployment` object.\n\n    Example:\n        Delete a deployment in the default namespace:\n        ```python\n        from prefect import flow\n        from prefect_kubernetes.credentials import KubernetesCredentials\n        from prefect_kubernetes.deployments import delete_namespaced_deployment\n        from kubernetes.client.models import V1DeleteOptions\n\n        @flow\n        def kubernetes_orchestrator():\n            v1_deployment_metadata = delete_namespaced_deployment(\n                kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n                deployment_name=\"test-deployment\",\n                delete_options=V1DeleteOptions(grace_period_seconds=0),\n            )\n        ```\n    \"\"\"\n    with kubernetes_credentials.get_client(\"core\") as core_v1_client:\n\n        return await run_sync_in_worker_thread(\n            core_v1_client.delete_namespaced_deployment,\n            deployment_name,\n            body=delete_options,\n            namespace=namespace,\n            **kube_kwargs,\n        )\n</code></pre>"},{"location":"deployments/#prefect_kubernetes.deployments.list_namespaced_deployment","title":"<code>list_namespaced_deployment</code>  <code>async</code>","text":"<p>List all deployments in a given namespace.</p> <p>Parameters:</p> Name Type Description Default <code>kubernetes_credentials</code> <code>KubernetesCredentials</code> <p><code>KubernetesCredentials</code> block for creating authenticated Kubernetes API clients.</p> required <code>namespace</code> <code>Optional[str]</code> <p>The Kubernetes namespace to list deployments from.</p> <code>'default'</code> <code>**kube_kwargs</code> <code>Dict[str, Any]</code> <p>Optional extra keyword arguments to pass to the Kubernetes API.</p> <code>{}</code> <p>Returns:</p> Type Description <code>V1DeploymentList</code> <p>A Kubernetes <code>V1DeploymentList</code> object.</p> Example <p>List all deployments in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.deployments import list_namespaced_deployment\n\n@flow\ndef kubernetes_orchestrator():\n    v1_deployment_list = list_namespaced_deployment(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\")\n    )\n</code></pre></p> Source code in <code>prefect_kubernetes/deployments.py</code> <pre><code>@task\nasync def list_namespaced_deployment(\n    kubernetes_credentials: KubernetesCredentials,\n    namespace: Optional[str] = \"default\",\n    **kube_kwargs: Dict[str, Any],\n) -&gt; V1DeploymentList:\n\"\"\"List all deployments in a given namespace.\n\n    Args:\n        kubernetes_credentials: `KubernetesCredentials` block for creating\n            authenticated Kubernetes API clients.\n        namespace: The Kubernetes namespace to list deployments from.\n        **kube_kwargs: Optional extra keyword arguments to pass to the Kubernetes API.\n\n    Returns:\n        A Kubernetes `V1DeploymentList` object.\n\n    Example:\n        List all deployments in the default namespace:\n        ```python\n        from prefect import flow\n        from prefect_kubernetes.credentials import KubernetesCredentials\n        from prefect_kubernetes.deployments import list_namespaced_deployment\n\n        @flow\n        def kubernetes_orchestrator():\n            v1_deployment_list = list_namespaced_deployment(\n                kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\")\n            )\n        ```\n    \"\"\"\n    with kubernetes_credentials.get_client(\"core\") as core_v1_client:\n\n        return await run_sync_in_worker_thread(\n            core_v1_client.list_namespaced_deployment,\n            namespace=namespace,\n            **kube_kwargs,\n        )\n</code></pre>"},{"location":"deployments/#prefect_kubernetes.deployments.patch_namespaced_deployment","title":"<code>patch_namespaced_deployment</code>  <code>async</code>","text":"<p>Patch a Kubernetes deployment in a given namespace.</p> <p>Parameters:</p> Name Type Description Default <code>kubernetes_credentials</code> <code>KubernetesCredentials</code> <p><code>KubernetesCredentials</code> block for creating authenticated Kubernetes API clients.</p> required <code>deployment_name</code> <code>str</code> <p>The name of the deployment to patch.</p> required <code>deployment_updates</code> <code>V1Deployment</code> <p>A Kubernetes <code>V1Deployment</code> object.</p> required <code>namespace</code> <code>Optional[str]</code> <p>The Kubernetes namespace to patch this deployment in.</p> <code>'default'</code> <code>**kube_kwargs</code> <code>Dict[str, Any]</code> <p>Optional extra keyword arguments to pass to the Kubernetes API.</p> <code>{}</code> <p>Returns:</p> Type Description <code>V1Deployment</code> <p>A Kubernetes <code>V1Deployment</code> object.</p> Example <p>Patch a deployment in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.deployments import patch_namespaced_deployment\nfrom kubernetes.client.models import V1Deployment\n\n@flow\ndef kubernetes_orchestrator():\n    v1_deployment_metadata = patch_namespaced_deployment(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        deployment_name=\"test-deployment\",\n        deployment_updates=V1Deployment(metadata={\"labels\": {\"foo\": \"bar\"}}),\n    )\n</code></pre></p> Source code in <code>prefect_kubernetes/deployments.py</code> <pre><code>@task\nasync def patch_namespaced_deployment(\n    kubernetes_credentials: KubernetesCredentials,\n    deployment_name: str,\n    deployment_updates: V1Deployment,\n    namespace: Optional[str] = \"default\",\n    **kube_kwargs: Dict[str, Any],\n) -&gt; V1Deployment:\n\"\"\"Patch a Kubernetes deployment in a given namespace.\n\n    Args:\n        kubernetes_credentials: `KubernetesCredentials` block for creating\n            authenticated Kubernetes API clients.\n        deployment_name: The name of the deployment to patch.\n        deployment_updates: A Kubernetes `V1Deployment` object.\n        namespace: The Kubernetes namespace to patch this deployment in.\n        **kube_kwargs: Optional extra keyword arguments to pass to the Kubernetes API.\n\n    Returns:\n        A Kubernetes `V1Deployment` object.\n\n    Example:\n        Patch a deployment in the default namespace:\n        ```python\n        from prefect import flow\n        from prefect_kubernetes.credentials import KubernetesCredentials\n        from prefect_kubernetes.deployments import patch_namespaced_deployment\n        from kubernetes.client.models import V1Deployment\n\n        @flow\n        def kubernetes_orchestrator():\n            v1_deployment_metadata = patch_namespaced_deployment(\n                kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n                deployment_name=\"test-deployment\",\n                deployment_updates=V1Deployment(metadata={\"labels\": {\"foo\": \"bar\"}}),\n            )\n        ```\n    \"\"\"\n    with kubernetes_credentials.get_client(\"core\") as core_v1_client:\n\n        return await run_sync_in_worker_thread(\n            core_v1_client.patch_namespaced_deployment,\n            name=deployment_name,\n            namespace=namespace,\n            body=deployment_updates,\n            **kube_kwargs,\n        )\n</code></pre>"},{"location":"deployments/#prefect_kubernetes.deployments.read_namespaced_deployment","title":"<code>read_namespaced_deployment</code>  <code>async</code>","text":"<p>Read information on a Kubernetes deployment in a given namespace.</p> <p>Parameters:</p> Name Type Description Default <code>kubernetes_credentials</code> <code>KubernetesCredentials</code> <p><code>KubernetesCredentials</code> block for creating authenticated Kubernetes API clients.</p> required <code>deployment_name</code> <code>str</code> <p>The name of the deployment to read.</p> required <code>namespace</code> <code>Optional[str]</code> <p>The Kubernetes namespace to read this deployment from.</p> <code>'default'</code> <code>**kube_kwargs</code> <code>Dict[str, Any]</code> <p>Optional extra keyword arguments to pass to the Kubernetes API.</p> <code>{}</code> <p>Returns:</p> Type Description <code>V1Deployment</code> <p>A Kubernetes <code>V1Deployment</code> object.</p> Example <p>Read a deployment in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\n\n@flow\ndef kubernetes_orchestrator():\n    v1_deployment_metadata = read_namespaced_deployment(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        deployment_name=\"test-deployment\"\n    )\n</code></pre></p> Source code in <code>prefect_kubernetes/deployments.py</code> <pre><code>@task\nasync def read_namespaced_deployment(\n    kubernetes_credentials: KubernetesCredentials,\n    deployment_name: str,\n    namespace: Optional[str] = \"default\",\n    **kube_kwargs: Dict[str, Any],\n) -&gt; V1Deployment:\n\"\"\"Read information on a Kubernetes deployment in a given namespace.\n\n    Args:\n        kubernetes_credentials: `KubernetesCredentials` block for creating\n            authenticated Kubernetes API clients.\n        deployment_name: The name of the deployment to read.\n        namespace: The Kubernetes namespace to read this deployment from.\n        **kube_kwargs: Optional extra keyword arguments to pass to the Kubernetes API.\n\n    Returns:\n        A Kubernetes `V1Deployment` object.\n\n    Example:\n        Read a deployment in the default namespace:\n        ```python\n        from prefect import flow\n        from prefect_kubernetes.credentials import KubernetesCredentials\n\n        @flow\n        def kubernetes_orchestrator():\n            v1_deployment_metadata = read_namespaced_deployment(\n                kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n                deployment_name=\"test-deployment\"\n            )\n        ```\n    \"\"\"\n    with kubernetes_credentials.get_client(\"core\") as core_v1_client:\n\n        return await run_sync_in_worker_thread(\n            core_v1_client.read_namespaced_deployment,\n            name=deployment_name,\n            namespace=namespace,\n            **kube_kwargs,\n        )\n</code></pre>"},{"location":"deployments/#prefect_kubernetes.deployments.replace_namespaced_deployment","title":"<code>replace_namespaced_deployment</code>  <code>async</code>","text":"<p>Replace a Kubernetes deployment in a given namespace.</p> <p>Parameters:</p> Name Type Description Default <code>kubernetes_credentials</code> <code>KubernetesCredentials</code> <p><code>KubernetesCredentials</code> block for creating authenticated Kubernetes API clients.</p> required <code>deployment_name</code> <code>str</code> <p>The name of the deployment to replace.</p> required <code>new_deployment</code> <code>V1Deployment</code> <p>A Kubernetes <code>V1Deployment</code> object.</p> required <code>namespace</code> <code>Optional[str]</code> <p>The Kubernetes namespace to replace this deployment in.</p> <code>'default'</code> <code>**kube_kwargs</code> <code>Dict[str, Any]</code> <p>Optional extra keyword arguments to pass to the Kubernetes API.</p> <code>{}</code> <p>Returns:</p> Type Description <code>V1Deployment</code> <p>A Kubernetes <code>V1Deployment</code> object.</p> Example <p>Replace a deployment in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.deployments import replace_namespaced_deployment\nfrom kubernetes.client.models import V1Deployment\n\n@flow\ndef kubernetes_orchestrator():\n    v1_deployment_metadata = replace_namespaced_deployment(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        deployment_name=\"test-deployment\",\n        new_deployment=V1Deployment(metadata={\"labels\": {\"foo\": \"bar\"}})\n    )\n</code></pre></p> Source code in <code>prefect_kubernetes/deployments.py</code> <pre><code>@task\nasync def replace_namespaced_deployment(\n    kubernetes_credentials: KubernetesCredentials,\n    deployment_name: str,\n    new_deployment: V1Deployment,\n    namespace: Optional[str] = \"default\",\n    **kube_kwargs: Dict[str, Any],\n) -&gt; V1Deployment:\n\"\"\"Replace a Kubernetes deployment in a given namespace.\n\n    Args:\n        kubernetes_credentials: `KubernetesCredentials` block for creating\n            authenticated Kubernetes API clients.\n        deployment_name: The name of the deployment to replace.\n        new_deployment: A Kubernetes `V1Deployment` object.\n        namespace: The Kubernetes namespace to replace this deployment in.\n        **kube_kwargs: Optional extra keyword arguments to pass to the Kubernetes API.\n\n    Returns:\n        A Kubernetes `V1Deployment` object.\n\n    Example:\n        Replace a deployment in the default namespace:\n        ```python\n        from prefect import flow\n        from prefect_kubernetes.credentials import KubernetesCredentials\n        from prefect_kubernetes.deployments import replace_namespaced_deployment\n        from kubernetes.client.models import V1Deployment\n\n        @flow\n        def kubernetes_orchestrator():\n            v1_deployment_metadata = replace_namespaced_deployment(\n                kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n                deployment_name=\"test-deployment\",\n                new_deployment=V1Deployment(metadata={\"labels\": {\"foo\": \"bar\"}})\n            )\n        ```\n    \"\"\"\n    with kubernetes_credentials.get_client(\"core\") as core_v1_client:\n\n        return await run_sync_in_worker_thread(\n            core_v1_client.replace_namespaced_deployment,\n            body=new_deployment,\n            name=deployment_name,\n            namespace=namespace,\n            **kube_kwargs,\n        )\n</code></pre>"},{"location":"examples_catalog/","title":"Examples Catalog","text":"<p>Below is a list of examples for <code>prefect-kubernetes</code>.</p>"},{"location":"examples_catalog/#credentials-module","title":"Credentials Module","text":"<pre><code>from prefect_kubernetes.credentials import KubernetesCredentials\n\nwith KubernetesCredentials.get_client(\"core\") as core_v1_client:\n    for pod in core_v1_client.list_namespaced_pod():\n        print(pod.metadata.name)\n</code></pre>"},{"location":"examples_catalog/#deployments-module","title":"Deployments Module","text":"<p>Create a deployment in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.deployments import create_namespaced_deployment\nfrom kubernetes.client.models import V1Deployment\n\n@flow\ndef kubernetes_orchestrator():\n    v1_deployment_metadata = create_namespaced_deployment(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        new_deployment=V1Deployment(metadata={\"name\": \"test-deployment\"}),\n    )\n</code></pre> Patch a deployment in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.deployments import patch_namespaced_deployment\nfrom kubernetes.client.models import V1Deployment\n\n@flow\ndef kubernetes_orchestrator():\n    v1_deployment_metadata = patch_namespaced_deployment(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        deployment_name=\"test-deployment\",\n        deployment_updates=V1Deployment(metadata={\"labels\": {\"foo\": \"bar\"}}),\n    )\n</code></pre> Replace a deployment in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.deployments import replace_namespaced_deployment\nfrom kubernetes.client.models import V1Deployment\n\n@flow\ndef kubernetes_orchestrator():\n    v1_deployment_metadata = replace_namespaced_deployment(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        deployment_name=\"test-deployment\",\n        new_deployment=V1Deployment(metadata={\"labels\": {\"foo\": \"bar\"}})\n    )\n</code></pre> Read a deployment in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\n\n@flow\ndef kubernetes_orchestrator():\n    v1_deployment_metadata = read_namespaced_deployment(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        deployment_name=\"test-deployment\"\n    )\n</code></pre> List all deployments in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.deployments import list_namespaced_deployment\n\n@flow\ndef kubernetes_orchestrator():\n    v1_deployment_list = list_namespaced_deployment(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\")\n    )\n</code></pre> Delete a deployment in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.deployments import delete_namespaced_deployment\nfrom kubernetes.client.models import V1DeleteOptions\n\n@flow\ndef kubernetes_orchestrator():\n    v1_deployment_metadata = delete_namespaced_deployment(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        deployment_name=\"test-deployment\",\n        delete_options=V1DeleteOptions(grace_period_seconds=0),\n    )\n</code></pre></p>"},{"location":"examples_catalog/#flows-module","title":"Flows Module","text":"<pre><code>from prefect_kubernetes import KubernetesJob, run_namespaced_job\nfrom prefect_kubernetes.credentials import KubernetesCredentials\n\nrun_namespaced_job(\n    kubernetes_job=KubernetesJob.from_yaml_file(\n        credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        manifest_path=\"path/to/job.yaml\",\n    )\n)\n</code></pre>"},{"location":"examples_catalog/#jobs-module","title":"Jobs Module","text":"<p>Read \"my-job\" in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.jobs import read_namespaced_job\n\n@flow\ndef kubernetes_orchestrator():\n    v1_job_metadata = read_namespaced_job(\n        job_name=\"my-job\",\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n    )\n</code></pre> List jobs in \"my-namespace\": <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.jobs import list_namespaced_job\n\n@flow\ndef kubernetes_orchestrator():\n    namespaced_job_list = list_namespaced_job(\n        namespace=\"my-namespace\",\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n    )\n</code></pre> Create a job in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.jobs import create_namespaced_job\nfrom kubernetes.client.models import V1Job\n\n@flow\ndef kubernetes_orchestrator():\n    v1_job_metadata = create_namespaced_job(\n        new_job=V1Job(metadata={\"labels\": {\"foo\": \"bar\"}}),\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n    )\n</code></pre> Delete \"my-job\" in the default namespace: <pre><code>from kubernetes.client.models import V1DeleteOptions\nfrom prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.jobs import delete_namespaced_job\n\n@flow\ndef kubernetes_orchestrator():\n    v1_job_status = delete_namespaced_job(\n        job_name=\"my-job\",\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        delete_options=V1DeleteOptions(propagation_policy=\"Foreground\"),\n    )\n</code></pre> Replace \"my-job\" in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.jobs import replace_namespaced_job\n\n@flow\ndef kubernetes_orchestrator():\n    v1_job_metadata = replace_namespaced_job(\n        new_job=V1Job(metadata={\"labels\": {\"foo\": \"bar\"}}),\n        job_name=\"my-job\",\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n    )\n</code></pre> Fetch status of a job in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.jobs import read_namespaced_job_status\n\n@flow\ndef kubernetes_orchestrator():\n    v1_job_status = read_namespaced_job_status(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        job_name=\"my-job\",\n    )\n</code></pre> Patch \"my-job\" in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.jobs import patch_namespaced_job\n\nfrom kubernetes.client.models import V1Job\n\n@flow\ndef kubernetes_orchestrator():\n    v1_job_metadata = patch_namespaced_job(\n        job_name=\"my-job\",\n        job_updates=V1Job(metadata={\"labels\": {\"foo\": \"bar\"}}}),\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n    )\n</code></pre></p>"},{"location":"examples_catalog/#pods-module","title":"Pods Module","text":"<p>Delete a pod in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.pods import delete_namespaced_pod\nfrom kubernetes.client.models import V1DeleteOptions\n\n@flow\ndef kubernetes_orchestrator():\n    v1_pod_metadata = delete_namespaced_pod(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        pod_name=\"test-pod\",\n        delete_options=V1DeleteOptions(grace_period_seconds=0),\n    )\n</code></pre> Read a pod in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\n\n@flow\ndef kubernetes_orchestrator():\n    v1_pod_metadata = read_namespaced_pod(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        pod_name=\"test-pod\"\n    )\n</code></pre> Replace a pod in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.pods import replace_namespaced_pod\nfrom kubernetes.client.models import V1Pod\n\n@flow\ndef kubernetes_orchestrator():\n    v1_pod_metadata = replace_namespaced_pod(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        pod_name=\"test-pod\",\n        new_pod=V1Pod(metadata={\"labels\": {\"foo\": \"bar\"}})\n    )\n</code></pre> Read logs from a pod in the default namespace: <pre><code>from prefect import flow, get_run_logger\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.pods import read_namespaced_pod_logs\n\n@flow\ndef kubernetes_orchestrator():\n    logger = get_run_logger()\n\n    pod_logs = read_namespaced_pod_logs(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        pod_name=\"test-pod\",\n        container=\"test-container\",\n        print_func=logger.info\n    )\n</code></pre> List all pods in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.pods import list_namespaced_pod\n\n@flow\ndef kubernetes_orchestrator():\n    v1_pod_list = list_namespaced_pod(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\")\n    )\n</code></pre> Patch a pod in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.pods import patch_namespaced_pod\nfrom kubernetes.client.models import V1Pod\n\n@flow\ndef kubernetes_orchestrator():\n    v1_pod_metadata = patch_namespaced_pod(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        pod_name=\"test-pod\",\n        pod_updates=V1Pod(metadata={\"labels\": {\"foo\": \"bar\"}}),\n    )\n</code></pre> Create a pod in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.pods import create_namespaced_pod\nfrom kubernetes.client.models import V1Pod\n\n@flow\ndef kubernetes_orchestrator():\n    v1_pod_metadata = create_namespaced_pod(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        new_pod=V1Pod(metadata={\"name\": \"test-pod\"}),\n    )\n</code></pre></p>"},{"location":"examples_catalog/#services-module","title":"Services Module","text":"<p><pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.services import list_namespaced_service\n\n@flow\ndef kubernetes_orchestrator():\n    list_namespaced_service(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        namespace=\"my-namespace\",\n    )\n</code></pre> <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.services import read_namespaced_service\n\n@flow\ndef kubernetes_orchestrator():\n    read_namespaced_service(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        service_name=\"my-service\",\n        namespace=\"my-namespace\",\n    )\n</code></pre> <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.services import patch_namespaced_service\nfrom kubernetes.client.models import V1Service\n\n@flow\ndef kubernetes_orchestrator():\n    patch_namespaced_service(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        service_name=\"my-service\",\n        new_service=V1Service(metadata={...}, spec={...}),\n        namespace=\"my-namespace\",\n    )\n</code></pre> <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.services import replace_namespaced_service\nfrom kubernetes.client.models import V1Service\n\n@flow\ndef kubernetes_orchestrator():\n    replace_namespaced_service(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        service_name=\"my-service\",\n        new_service=V1Service(metadata={...}, spec={...}),\n        namespace=\"my-namespace\",\n    )\n</code></pre> <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.services import delete_namespaced_service\n\n@flow\ndef kubernetes_orchestrator():\n    delete_namespaced_service(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        service_name=\"my-service\",\n        namespace=\"my-namespace\",\n    )\n</code></pre> <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.services import create_namespaced_service\nfrom kubernetes.client.models import V1Service\n\n@flow\ndef create_service_flow():\n    v1_service = create_namespaced_service(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        new_service=V1Service(metadata={...}, spec={...}),\n    )\n</code></pre></p>"},{"location":"exceptions/","title":"Exceptions","text":""},{"location":"exceptions/#prefect_kubernetes.exceptions","title":"<code>prefect_kubernetes.exceptions</code>","text":"<p>Module to define common exceptions within <code>prefect_kubernetes</code>.</p>"},{"location":"exceptions/#prefect_kubernetes.exceptions-classes","title":"Classes","text":""},{"location":"exceptions/#prefect_kubernetes.exceptions.KubernetesJobDefinitionError","title":"<code>KubernetesJobDefinitionError</code>","text":"<p>         Bases: <code>OpenApiException</code></p> <p>An exception for when a Kubernetes job definition is invalid.</p> Source code in <code>prefect_kubernetes/exceptions.py</code> <pre><code>class KubernetesJobDefinitionError(OpenApiException):\n\"\"\"An exception for when a Kubernetes job definition is invalid.\"\"\"\n</code></pre>"},{"location":"exceptions/#prefect_kubernetes.exceptions.KubernetesJobFailedError","title":"<code>KubernetesJobFailedError</code>","text":"<p>         Bases: <code>OpenApiException</code></p> <p>An exception for when a Kubernetes job fails.</p> Source code in <code>prefect_kubernetes/exceptions.py</code> <pre><code>class KubernetesJobFailedError(OpenApiException):\n\"\"\"An exception for when a Kubernetes job fails.\"\"\"\n</code></pre>"},{"location":"exceptions/#prefect_kubernetes.exceptions.KubernetesJobTimeoutError","title":"<code>KubernetesJobTimeoutError</code>","text":"<p>         Bases: <code>OpenApiException</code></p> <p>An exception for when a Kubernetes job times out.</p> Source code in <code>prefect_kubernetes/exceptions.py</code> <pre><code>class KubernetesJobTimeoutError(OpenApiException):\n\"\"\"An exception for when a Kubernetes job times out.\"\"\"\n</code></pre>"},{"location":"exceptions/#prefect_kubernetes.exceptions.KubernetesResourceNotFoundError","title":"<code>KubernetesResourceNotFoundError</code>","text":"<p>         Bases: <code>ApiException</code></p> <p>An exception for when a Kubernetes resource cannot be found by a client.</p> Source code in <code>prefect_kubernetes/exceptions.py</code> <pre><code>class KubernetesResourceNotFoundError(ApiException):\n\"\"\"An exception for when a Kubernetes resource cannot be found by a client.\"\"\"\n</code></pre>"},{"location":"flows/","title":"Flows","text":""},{"location":"flows/#prefect_kubernetes.flows","title":"<code>prefect_kubernetes.flows</code>","text":"<p>A module to define flows interacting with Kubernetes resources.</p>"},{"location":"flows/#prefect_kubernetes.flows-classes","title":"Classes","text":""},{"location":"flows/#prefect_kubernetes.flows-functions","title":"Functions","text":""},{"location":"flows/#prefect_kubernetes.flows.run_namespaced_job","title":"<code>run_namespaced_job</code>  <code>async</code>","text":"<p>Flow for running a namespaced Kubernetes job.</p> <p>Parameters:</p> Name Type Description Default <code>kubernetes_job</code> <code>KubernetesJob</code> <p>The <code>KubernetesJob</code> block that specifies the job to run.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>The a dict of logs from each pod in the job, e.g. {'pod_name': 'pod_log_str'}.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the created Kubernetes job attains a failed status.</p> Example <pre><code>from prefect_kubernetes import KubernetesJob, run_namespaced_job\nfrom prefect_kubernetes.credentials import KubernetesCredentials\n\nrun_namespaced_job(\n    kubernetes_job=KubernetesJob.from_yaml_file(\n        credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        manifest_path=\"path/to/job.yaml\",\n    )\n)\n</code></pre> Source code in <code>prefect_kubernetes/flows.py</code> <pre><code>@flow\nasync def run_namespaced_job(\n    kubernetes_job: KubernetesJob,\n) -&gt; Dict[str, Any]:\n\"\"\"Flow for running a namespaced Kubernetes job.\n\n    Args:\n        kubernetes_job: The `KubernetesJob` block that specifies the job to run.\n\n    Returns:\n        The a dict of logs from each pod in the job, e.g. {'pod_name': 'pod_log_str'}.\n\n    Raises:\n        RuntimeError: If the created Kubernetes job attains a failed status.\n\n    Example:\n\n        ```python\n        from prefect_kubernetes import KubernetesJob, run_namespaced_job\n        from prefect_kubernetes.credentials import KubernetesCredentials\n\n        run_namespaced_job(\n            kubernetes_job=KubernetesJob.from_yaml_file(\n                credentials=KubernetesCredentials.load(\"k8s-creds\"),\n                manifest_path=\"path/to/job.yaml\",\n            )\n        )\n        ```\n    \"\"\"\n    kubernetes_job_run = await task(kubernetes_job.trigger.aio)(kubernetes_job)\n\n    await task(kubernetes_job_run.wait_for_completion.aio)(kubernetes_job_run)\n\n    return await task(kubernetes_job_run.fetch_result.aio)(kubernetes_job_run)\n</code></pre>"},{"location":"jobs/","title":"Jobs","text":""},{"location":"jobs/#prefect_kubernetes.jobs","title":"<code>prefect_kubernetes.jobs</code>","text":"<p>Module to define tasks for interacting with Kubernetes jobs.</p>"},{"location":"jobs/#prefect_kubernetes.jobs-classes","title":"Classes","text":""},{"location":"jobs/#prefect_kubernetes.jobs.KubernetesJob","title":"<code>KubernetesJob</code>","text":"<p>         Bases: <code>JobBlock</code></p> <p>A block representing a Kubernetes job configuration.</p> Source code in <code>prefect_kubernetes/jobs.py</code> <pre><code>class KubernetesJob(JobBlock):\n\"\"\"A block representing a Kubernetes job configuration.\"\"\"\n\n    v1_job: Dict[str, Any] = Field(\n        default=...,\n        title=\"Job Manifest\",\n        description=(\n            \"The Kubernetes job manifest to run. This dictionary can be produced \"\n            \"using `yaml.safe_load`.\"\n        ),\n    )\n    api_kwargs: Dict[str, Any] = Field(\n        default_factory=dict,\n        title=\"Additional API Arguments\",\n        description=\"Additional arguments to include in Kubernetes API calls.\",\n        example={\"pretty\": \"true\"},\n    )\n    credentials: KubernetesCredentials = Field(\n        default=..., description=\"The credentials to configure a client from.\"\n    )\n    delete_after_completion: bool = Field(\n        default=True,\n        description=\"Whether to delete the job after it has completed.\",\n    )\n    interval_seconds: int = Field(\n        default=5,\n        description=\"The number of seconds to wait between job status checks.\",\n    )\n    namespace: str = Field(\n        default=\"default\",\n        description=\"The namespace to create and run the job in.\",\n    )\n    timeout_seconds: Optional[int] = Field(\n        default=None,\n        description=\"The number of seconds to wait for the job run before timing out.\",\n    )\n\n    _block_type_name = \"Kubernetes Job\"\n    _block_type_slug = \"k8s-job\"\n    _logo_url = \"https://images.ctfassets.net/zscdif0zqppk/35vNcprr3MmIlkrKxxCiah/1d720b4b50dfa8876198cf21730cf123/Kubernetes_logo_without_workmark.svg.png?h=250\"  # noqa: E501\n    _documentation_url = \"https://prefecthq.github.io/prefect-kubernetes/jobs/#prefect_kubernetes.jobs.KubernetesJob\"  # noqa\n\n    @sync_compatible\n    async def trigger(self):\n\"\"\"Create a Kubernetes job and return a `KubernetesJobRun` object.\"\"\"\n\n        v1_job_model = convert_manifest_to_model(self.v1_job, \"V1Job\")\n\n        await create_namespaced_job.fn(\n            kubernetes_credentials=self.credentials,\n            new_job=v1_job_model,\n            namespace=self.namespace,\n            **self.api_kwargs,\n        )\n\n        return KubernetesJobRun(kubernetes_job=self, v1_job_model=v1_job_model)\n\n    @classmethod\n    def from_yaml_file(\n        cls: Type[Self], manifest_path: Union[Path, str], **kwargs\n    ) -&gt; Self:\n\"\"\"Create a `KubernetesJob` from a YAML file.\n\n        Args:\n            manifest_path: The YAML file to create the `KubernetesJob` from.\n\n        Returns:\n            A KubernetesJob object.\n        \"\"\"\n        with open(manifest_path, \"r\") as yaml_stream:\n            yaml_dict = yaml.safe_load(yaml_stream)\n\n        return cls(v1_job=yaml_dict, **kwargs)\n</code></pre>"},{"location":"jobs/#prefect_kubernetes.jobs.KubernetesJob-functions","title":"Functions","text":""},{"location":"jobs/#prefect_kubernetes.jobs.KubernetesJob.from_yaml_file","title":"<code>from_yaml_file</code>  <code>classmethod</code>","text":"<p>Create a <code>KubernetesJob</code> from a YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>manifest_path</code> <code>Union[Path, str]</code> <p>The YAML file to create the <code>KubernetesJob</code> from.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>A KubernetesJob object.</p> Source code in <code>prefect_kubernetes/jobs.py</code> <pre><code>@classmethod\ndef from_yaml_file(\n    cls: Type[Self], manifest_path: Union[Path, str], **kwargs\n) -&gt; Self:\n\"\"\"Create a `KubernetesJob` from a YAML file.\n\n    Args:\n        manifest_path: The YAML file to create the `KubernetesJob` from.\n\n    Returns:\n        A KubernetesJob object.\n    \"\"\"\n    with open(manifest_path, \"r\") as yaml_stream:\n        yaml_dict = yaml.safe_load(yaml_stream)\n\n    return cls(v1_job=yaml_dict, **kwargs)\n</code></pre>"},{"location":"jobs/#prefect_kubernetes.jobs.KubernetesJob.trigger","title":"<code>trigger</code>  <code>async</code>","text":"<p>Create a Kubernetes job and return a <code>KubernetesJobRun</code> object.</p> Source code in <code>prefect_kubernetes/jobs.py</code> <pre><code>@sync_compatible\nasync def trigger(self):\n\"\"\"Create a Kubernetes job and return a `KubernetesJobRun` object.\"\"\"\n\n    v1_job_model = convert_manifest_to_model(self.v1_job, \"V1Job\")\n\n    await create_namespaced_job.fn(\n        kubernetes_credentials=self.credentials,\n        new_job=v1_job_model,\n        namespace=self.namespace,\n        **self.api_kwargs,\n    )\n\n    return KubernetesJobRun(kubernetes_job=self, v1_job_model=v1_job_model)\n</code></pre>"},{"location":"jobs/#prefect_kubernetes.jobs.KubernetesJobRun","title":"<code>KubernetesJobRun</code>","text":"<p>         Bases: <code>JobRun[Dict[str, Any]]</code></p> <p>A container representing a run of a Kubernetes job.</p> Source code in <code>prefect_kubernetes/jobs.py</code> <pre><code>class KubernetesJobRun(JobRun[Dict[str, Any]]):\n\"\"\"A container representing a run of a Kubernetes job.\"\"\"\n\n    def __init__(\n        self,\n        kubernetes_job: \"KubernetesJob\",\n        v1_job_model: V1Job,\n    ):\n        self.pod_logs = None\n\n        self._completed = False\n        self._kubernetes_job = kubernetes_job\n        self._v1_job_model = v1_job_model\n\n    async def _cleanup(self):\n\"\"\"Deletes the Kubernetes job resource.\"\"\"\n\n        delete_options = V1DeleteOptions(propagation_policy=\"Foreground\")\n\n        deleted_v1_job = await delete_namespaced_job.fn(\n            kubernetes_credentials=self._kubernetes_job.credentials,\n            job_name=self._v1_job_model.metadata.name,\n            delete_options=delete_options,\n            namespace=self._kubernetes_job.namespace,\n            **self._kubernetes_job.api_kwargs,\n        )\n        self.logger.info(\n            f\"Job {self._v1_job_model.metadata.name} deleted \"\n            f\"with {deleted_v1_job.status!r}.\"\n        )\n\n    @sync_compatible\n    async def wait_for_completion(self):\n\"\"\"Waits for the job to complete.\n\n        If the job has `delete_after_completion` set to `True`,\n        the job will be deleted if it is observed by this method\n        to enter a completed state.\n\n        Raises:\n            RuntimeError: If the Kubernetes job fails.\n            KubernetesJobTimeoutError: If the Kubernetes job times out.\n            ValueError: If `wait_for_completion` is never called.\n        \"\"\"\n        self.pod_logs = {}\n\n        elapsed_time = 0\n\n        while not self._completed:\n            job_expired = (\n                elapsed_time &gt; self._kubernetes_job.timeout_seconds\n                if self._kubernetes_job.timeout_seconds\n                else False\n            )\n            if job_expired:\n                raise KubernetesJobTimeoutError(\n                    f\"Job timed out after {elapsed_time} seconds.\"\n                )\n\n            v1_job_status = await read_namespaced_job_status.fn(\n                kubernetes_credentials=self._kubernetes_job.credentials,\n                job_name=self._v1_job_model.metadata.name,\n                namespace=self._kubernetes_job.namespace,\n                **self._kubernetes_job.api_kwargs,\n            )\n            pod_selector = (\n                \"controller-uid=\" f\"{v1_job_status.metadata.labels['controller-uid']}\"\n            )\n            v1_pod_list = await list_namespaced_pod.fn(\n                kubernetes_credentials=self._kubernetes_job.credentials,\n                namespace=self._kubernetes_job.namespace,\n                label_selector=pod_selector,\n                **self._kubernetes_job.api_kwargs,\n            )\n\n            for pod in v1_pod_list.items:\n                pod_name = pod.metadata.name\n\n                if pod.status.phase == \"Pending\" or pod_name in self.pod_logs.keys():\n                    continue\n\n                self.logger.info(f\"Capturing logs for pod {pod_name!r}.\")\n\n                self.pod_logs[pod_name] = await read_namespaced_pod_log.fn(\n                    kubernetes_credentials=self._kubernetes_job.credentials,\n                    pod_name=pod_name,\n                    container=v1_job_status.spec.template.spec.containers[0].name,\n                    namespace=self._kubernetes_job.namespace,\n                    **self._kubernetes_job.api_kwargs,\n                )\n\n            if v1_job_status.status.active:\n                await sleep(self._kubernetes_job.interval_seconds)\n                if self._kubernetes_job.timeout_seconds:\n                    elapsed_time += self._kubernetes_job.interval_seconds\n            elif v1_job_status.status.failed:\n                raise RuntimeError(\n                    f\"Job {v1_job_status.metadata.name!r} failed, check the \"\n                    \"Kubernetes pod logs for more information.\"\n                )\n            elif v1_job_status.status.succeeded:\n                self._completed = True\n                self.logger.info(f\"Job {v1_job_status.metadata.name!r} has completed.\")\n\n        if self._kubernetes_job.delete_after_completion:\n            await self._cleanup()\n\n    @sync_compatible\n    async def fetch_result(self) -&gt; Dict[str, Any]:\n\"\"\"Fetch the results of the job.\n\n        Returns:\n            The logs from each of the pods in the job.\n\n        Raises:\n            ValueError: If this method is called when the job has\n                a non-terminal state.\n        \"\"\"\n\n        if not self._completed:\n            raise ValueError(\n                \"The Kubernetes Job run is not in a completed state - \"\n                \"be sure to call `wait_for_completion` before attempting \"\n                \"to fetch the result.\"\n            )\n        return self.pod_logs\n</code></pre>"},{"location":"jobs/#prefect_kubernetes.jobs.KubernetesJobRun-functions","title":"Functions","text":""},{"location":"jobs/#prefect_kubernetes.jobs.KubernetesJobRun.fetch_result","title":"<code>fetch_result</code>  <code>async</code>","text":"<p>Fetch the results of the job.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>The logs from each of the pods in the job.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If this method is called when the job has a non-terminal state.</p> Source code in <code>prefect_kubernetes/jobs.py</code> <pre><code>@sync_compatible\nasync def fetch_result(self) -&gt; Dict[str, Any]:\n\"\"\"Fetch the results of the job.\n\n    Returns:\n        The logs from each of the pods in the job.\n\n    Raises:\n        ValueError: If this method is called when the job has\n            a non-terminal state.\n    \"\"\"\n\n    if not self._completed:\n        raise ValueError(\n            \"The Kubernetes Job run is not in a completed state - \"\n            \"be sure to call `wait_for_completion` before attempting \"\n            \"to fetch the result.\"\n        )\n    return self.pod_logs\n</code></pre>"},{"location":"jobs/#prefect_kubernetes.jobs.KubernetesJobRun.wait_for_completion","title":"<code>wait_for_completion</code>  <code>async</code>","text":"<p>Waits for the job to complete.</p> <p>If the job has <code>delete_after_completion</code> set to <code>True</code>, the job will be deleted if it is observed by this method to enter a completed state.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the Kubernetes job fails.</p> <code>KubernetesJobTimeoutError</code> <p>If the Kubernetes job times out.</p> <code>ValueError</code> <p>If <code>wait_for_completion</code> is never called.</p> Source code in <code>prefect_kubernetes/jobs.py</code> <pre><code>@sync_compatible\nasync def wait_for_completion(self):\n\"\"\"Waits for the job to complete.\n\n    If the job has `delete_after_completion` set to `True`,\n    the job will be deleted if it is observed by this method\n    to enter a completed state.\n\n    Raises:\n        RuntimeError: If the Kubernetes job fails.\n        KubernetesJobTimeoutError: If the Kubernetes job times out.\n        ValueError: If `wait_for_completion` is never called.\n    \"\"\"\n    self.pod_logs = {}\n\n    elapsed_time = 0\n\n    while not self._completed:\n        job_expired = (\n            elapsed_time &gt; self._kubernetes_job.timeout_seconds\n            if self._kubernetes_job.timeout_seconds\n            else False\n        )\n        if job_expired:\n            raise KubernetesJobTimeoutError(\n                f\"Job timed out after {elapsed_time} seconds.\"\n            )\n\n        v1_job_status = await read_namespaced_job_status.fn(\n            kubernetes_credentials=self._kubernetes_job.credentials,\n            job_name=self._v1_job_model.metadata.name,\n            namespace=self._kubernetes_job.namespace,\n            **self._kubernetes_job.api_kwargs,\n        )\n        pod_selector = (\n            \"controller-uid=\" f\"{v1_job_status.metadata.labels['controller-uid']}\"\n        )\n        v1_pod_list = await list_namespaced_pod.fn(\n            kubernetes_credentials=self._kubernetes_job.credentials,\n            namespace=self._kubernetes_job.namespace,\n            label_selector=pod_selector,\n            **self._kubernetes_job.api_kwargs,\n        )\n\n        for pod in v1_pod_list.items:\n            pod_name = pod.metadata.name\n\n            if pod.status.phase == \"Pending\" or pod_name in self.pod_logs.keys():\n                continue\n\n            self.logger.info(f\"Capturing logs for pod {pod_name!r}.\")\n\n            self.pod_logs[pod_name] = await read_namespaced_pod_log.fn(\n                kubernetes_credentials=self._kubernetes_job.credentials,\n                pod_name=pod_name,\n                container=v1_job_status.spec.template.spec.containers[0].name,\n                namespace=self._kubernetes_job.namespace,\n                **self._kubernetes_job.api_kwargs,\n            )\n\n        if v1_job_status.status.active:\n            await sleep(self._kubernetes_job.interval_seconds)\n            if self._kubernetes_job.timeout_seconds:\n                elapsed_time += self._kubernetes_job.interval_seconds\n        elif v1_job_status.status.failed:\n            raise RuntimeError(\n                f\"Job {v1_job_status.metadata.name!r} failed, check the \"\n                \"Kubernetes pod logs for more information.\"\n            )\n        elif v1_job_status.status.succeeded:\n            self._completed = True\n            self.logger.info(f\"Job {v1_job_status.metadata.name!r} has completed.\")\n\n    if self._kubernetes_job.delete_after_completion:\n        await self._cleanup()\n</code></pre>"},{"location":"jobs/#prefect_kubernetes.jobs-functions","title":"Functions","text":""},{"location":"jobs/#prefect_kubernetes.jobs.create_namespaced_job","title":"<code>create_namespaced_job</code>  <code>async</code>","text":"<p>Task for creating a namespaced Kubernetes job.</p> <p>Parameters:</p> Name Type Description Default <code>kubernetes_credentials</code> <code>KubernetesCredentials</code> <p><code>KubernetesCredentials</code> block holding authentication needed to generate the required API client.</p> required <code>new_job</code> <code>V1Job</code> <p>A Kubernetes <code>V1Job</code> specification.</p> required <code>namespace</code> <code>Optional[str]</code> <p>The Kubernetes namespace to create this job in.</p> <code>'default'</code> <code>**kube_kwargs</code> <code>Dict[str, Any]</code> <p>Optional extra keyword arguments to pass to the Kubernetes API (e.g. <code>{\"pretty\": \"...\", \"dry_run\": \"...\"}</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>V1Job</code> <p>A Kubernetes <code>V1Job</code> object.</p> Example <p>Create a job in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.jobs import create_namespaced_job\nfrom kubernetes.client.models import V1Job\n\n@flow\ndef kubernetes_orchestrator():\n    v1_job_metadata = create_namespaced_job(\n        new_job=V1Job(metadata={\"labels\": {\"foo\": \"bar\"}}),\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n    )\n</code></pre></p> Source code in <code>prefect_kubernetes/jobs.py</code> <pre><code>@task\nasync def create_namespaced_job(\n    kubernetes_credentials: KubernetesCredentials,\n    new_job: V1Job,\n    namespace: Optional[str] = \"default\",\n    **kube_kwargs: Dict[str, Any],\n) -&gt; V1Job:\n\"\"\"Task for creating a namespaced Kubernetes job.\n\n    Args:\n        kubernetes_credentials: `KubernetesCredentials` block\n            holding authentication needed to generate the required API client.\n        new_job: A Kubernetes `V1Job` specification.\n        namespace: The Kubernetes namespace to create this job in.\n        **kube_kwargs: Optional extra keyword arguments to pass to the\n            Kubernetes API (e.g. `{\"pretty\": \"...\", \"dry_run\": \"...\"}`).\n\n    Returns:\n        A Kubernetes `V1Job` object.\n\n    Example:\n        Create a job in the default namespace:\n        ```python\n        from prefect import flow\n        from prefect_kubernetes.credentials import KubernetesCredentials\n        from prefect_kubernetes.jobs import create_namespaced_job\n        from kubernetes.client.models import V1Job\n\n        @flow\n        def kubernetes_orchestrator():\n            v1_job_metadata = create_namespaced_job(\n                new_job=V1Job(metadata={\"labels\": {\"foo\": \"bar\"}}),\n                kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n            )\n        ```\n    \"\"\"\n    with kubernetes_credentials.get_client(\"batch\") as batch_v1_client:\n        return await run_sync_in_worker_thread(\n            batch_v1_client.create_namespaced_job,\n            namespace=namespace,\n            body=new_job,\n            **kube_kwargs,\n        )\n</code></pre>"},{"location":"jobs/#prefect_kubernetes.jobs.delete_namespaced_job","title":"<code>delete_namespaced_job</code>  <code>async</code>","text":"<p>Task for deleting a namespaced Kubernetes job.</p> <p>Parameters:</p> Name Type Description Default <code>kubernetes_credentials</code> <code>KubernetesCredentials</code> <p><code>KubernetesCredentials</code> block holding authentication needed to generate the required API client.</p> required <code>job_name</code> <code>str</code> <p>The name of a job to delete.</p> required <code>delete_options</code> <code>Optional[V1DeleteOptions]</code> <p>A Kubernetes <code>V1DeleteOptions</code> object.</p> <code>None</code> <code>namespace</code> <code>Optional[str]</code> <p>The Kubernetes namespace to delete this job in.</p> <code>'default'</code> <code>**kube_kwargs</code> <code>Dict[str, Any]</code> <p>Optional extra keyword arguments to pass to the Kubernetes API (e.g. <code>{\"pretty\": \"...\", \"dry_run\": \"...\"}</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>V1Status</code> <p>A Kubernetes <code>V1Status</code> object.</p> Example <p>Delete \"my-job\" in the default namespace: <pre><code>from kubernetes.client.models import V1DeleteOptions\nfrom prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.jobs import delete_namespaced_job\n\n@flow\ndef kubernetes_orchestrator():\n    v1_job_status = delete_namespaced_job(\n        job_name=\"my-job\",\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        delete_options=V1DeleteOptions(propagation_policy=\"Foreground\"),\n    )\n</code></pre></p> Source code in <code>prefect_kubernetes/jobs.py</code> <pre><code>@task\nasync def delete_namespaced_job(\n    kubernetes_credentials: KubernetesCredentials,\n    job_name: str,\n    delete_options: Optional[V1DeleteOptions] = None,\n    namespace: Optional[str] = \"default\",\n    **kube_kwargs: Dict[str, Any],\n) -&gt; V1Status:\n\"\"\"Task for deleting a namespaced Kubernetes job.\n\n    Args:\n        kubernetes_credentials: `KubernetesCredentials` block\n            holding authentication needed to generate the required API client.\n        job_name: The name of a job to delete.\n        delete_options: A Kubernetes `V1DeleteOptions` object.\n        namespace: The Kubernetes namespace to delete this job in.\n        **kube_kwargs: Optional extra keyword arguments to pass to the\n            Kubernetes API (e.g. `{\"pretty\": \"...\", \"dry_run\": \"...\"}`).\n\n\n    Returns:\n        A Kubernetes `V1Status` object.\n\n    Example:\n        Delete \"my-job\" in the default namespace:\n        ```python\n        from kubernetes.client.models import V1DeleteOptions\n        from prefect import flow\n        from prefect_kubernetes.credentials import KubernetesCredentials\n        from prefect_kubernetes.jobs import delete_namespaced_job\n\n        @flow\n        def kubernetes_orchestrator():\n            v1_job_status = delete_namespaced_job(\n                job_name=\"my-job\",\n                kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n                delete_options=V1DeleteOptions(propagation_policy=\"Foreground\"),\n            )\n        ```\n    \"\"\"\n\n    with kubernetes_credentials.get_client(\"batch\") as batch_v1_client:\n        return await run_sync_in_worker_thread(\n            batch_v1_client.delete_namespaced_job,\n            name=job_name,\n            body=delete_options,\n            namespace=namespace,\n            **kube_kwargs,\n        )\n</code></pre>"},{"location":"jobs/#prefect_kubernetes.jobs.list_namespaced_job","title":"<code>list_namespaced_job</code>  <code>async</code>","text":"<p>Task for listing namespaced Kubernetes jobs.</p> <p>Parameters:</p> Name Type Description Default <code>kubernetes_credentials</code> <code>KubernetesCredentials</code> <p><code>KubernetesCredentials</code> block holding authentication needed to generate the required API client.</p> required <code>namespace</code> <code>Optional[str]</code> <p>The Kubernetes namespace to list jobs from.</p> <code>'default'</code> <code>**kube_kwargs</code> <code>Dict[str, Any]</code> <p>Optional extra keyword arguments to pass to the Kubernetes API (e.g. <code>{\"pretty\": \"...\", \"dry_run\": \"...\"}</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>V1JobList</code> <p>A Kubernetes <code>V1JobList</code> object.</p> Example <p>List jobs in \"my-namespace\": <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.jobs import list_namespaced_job\n\n@flow\ndef kubernetes_orchestrator():\n    namespaced_job_list = list_namespaced_job(\n        namespace=\"my-namespace\",\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n    )\n</code></pre></p> Source code in <code>prefect_kubernetes/jobs.py</code> <pre><code>@task\nasync def list_namespaced_job(\n    kubernetes_credentials: KubernetesCredentials,\n    namespace: Optional[str] = \"default\",\n    **kube_kwargs: Dict[str, Any],\n) -&gt; V1JobList:\n\"\"\"Task for listing namespaced Kubernetes jobs.\n\n    Args:\n        kubernetes_credentials: `KubernetesCredentials` block\n            holding authentication needed to generate the required API client.\n        namespace: The Kubernetes namespace to list jobs from.\n        **kube_kwargs: Optional extra keyword arguments to pass to the\n            Kubernetes API (e.g. `{\"pretty\": \"...\", \"dry_run\": \"...\"}`).\n\n    Returns:\n        A Kubernetes `V1JobList` object.\n\n    Example:\n        List jobs in \"my-namespace\":\n        ```python\n        from prefect import flow\n        from prefect_kubernetes.credentials import KubernetesCredentials\n        from prefect_kubernetes.jobs import list_namespaced_job\n\n        @flow\n        def kubernetes_orchestrator():\n            namespaced_job_list = list_namespaced_job(\n                namespace=\"my-namespace\",\n                kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n            )\n        ```\n    \"\"\"\n    with kubernetes_credentials.get_client(\"batch\") as batch_v1_client:\n        return await run_sync_in_worker_thread(\n            batch_v1_client.list_namespaced_job,\n            namespace=namespace,\n            **kube_kwargs,\n        )\n</code></pre>"},{"location":"jobs/#prefect_kubernetes.jobs.patch_namespaced_job","title":"<code>patch_namespaced_job</code>  <code>async</code>","text":"<p>Task for patching a namespaced Kubernetes job.</p> <p>Parameters:</p> Name Type Description Default <code>kubernetes_credentials</code> <code>KubernetesCredentials</code> <p>KubernetesCredentials block holding authentication needed to generate the required API client.</p> required <code>job_name</code> <code>str</code> <p>The name of a job to patch.</p> required <code>job_updates</code> <code>V1Job</code> <p>A Kubernetes <code>V1Job</code> specification.</p> required <code>namespace</code> <code>Optional[str]</code> <p>The Kubernetes namespace to patch this job in.</p> <code>'default'</code> <code>**kube_kwargs</code> <code>Dict[str, Any]</code> <p>Optional extra keyword arguments to pass to the Kubernetes API (e.g. <code>{\"pretty\": \"...\", \"dry_run\": \"...\"}</code>).</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if <code>job_name</code> is <code>None</code>.</p> <p>Returns:</p> Type Description <code>V1Job</code> <p>A Kubernetes <code>V1Job</code> object.</p> Example <p>Patch \"my-job\" in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.jobs import patch_namespaced_job\n\nfrom kubernetes.client.models import V1Job\n\n@flow\ndef kubernetes_orchestrator():\n    v1_job_metadata = patch_namespaced_job(\n        job_name=\"my-job\",\n        job_updates=V1Job(metadata={\"labels\": {\"foo\": \"bar\"}}}),\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n    )\n</code></pre></p> Source code in <code>prefect_kubernetes/jobs.py</code> <pre><code>@task\nasync def patch_namespaced_job(\n    kubernetes_credentials: KubernetesCredentials,\n    job_name: str,\n    job_updates: V1Job,\n    namespace: Optional[str] = \"default\",\n    **kube_kwargs: Dict[str, Any],\n) -&gt; V1Job:\n\"\"\"Task for patching a namespaced Kubernetes job.\n\n    Args:\n        kubernetes_credentials: KubernetesCredentials block\n            holding authentication needed to generate the required API client.\n        job_name: The name of a job to patch.\n        job_updates: A Kubernetes `V1Job` specification.\n        namespace: The Kubernetes namespace to patch this job in.\n        **kube_kwargs: Optional extra keyword arguments to pass to the\n            Kubernetes API (e.g. `{\"pretty\": \"...\", \"dry_run\": \"...\"}`).\n\n    Raises:\n        ValueError: if `job_name` is `None`.\n\n    Returns:\n        A Kubernetes `V1Job` object.\n\n    Example:\n        Patch \"my-job\" in the default namespace:\n        ```python\n        from prefect import flow\n        from prefect_kubernetes.credentials import KubernetesCredentials\n        from prefect_kubernetes.jobs import patch_namespaced_job\n\n        from kubernetes.client.models import V1Job\n\n        @flow\n        def kubernetes_orchestrator():\n            v1_job_metadata = patch_namespaced_job(\n                job_name=\"my-job\",\n                job_updates=V1Job(metadata={\"labels\": {\"foo\": \"bar\"}}}),\n                kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n            )\n        ```\n    \"\"\"\n\n    with kubernetes_credentials.get_client(\"batch\") as batch_v1_client:\n        return await run_sync_in_worker_thread(\n            batch_v1_client.patch_namespaced_job,\n            name=job_name,\n            namespace=namespace,\n            body=job_updates,\n            **kube_kwargs,\n        )\n</code></pre>"},{"location":"jobs/#prefect_kubernetes.jobs.read_namespaced_job","title":"<code>read_namespaced_job</code>  <code>async</code>","text":"<p>Task for reading a namespaced Kubernetes job.</p> <p>Parameters:</p> Name Type Description Default <code>kubernetes_credentials</code> <code>KubernetesCredentials</code> <p><code>KubernetesCredentials</code> block holding authentication needed to generate the required API client.</p> required <code>job_name</code> <code>str</code> <p>The name of a job to read.</p> required <code>namespace</code> <code>Optional[str]</code> <p>The Kubernetes namespace to read this job in.</p> <code>'default'</code> <code>**kube_kwargs</code> <code>Dict[str, Any]</code> <p>Optional extra keyword arguments to pass to the Kubernetes API (e.g. <code>{\"pretty\": \"...\", \"dry_run\": \"...\"}</code>).</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if <code>job_name</code> is <code>None</code>.</p> <p>Returns:</p> Type Description <code>V1Job</code> <p>A Kubernetes <code>V1Job</code> object.</p> Example <p>Read \"my-job\" in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.jobs import read_namespaced_job\n\n@flow\ndef kubernetes_orchestrator():\n    v1_job_metadata = read_namespaced_job(\n        job_name=\"my-job\",\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n    )\n</code></pre></p> Source code in <code>prefect_kubernetes/jobs.py</code> <pre><code>@task\nasync def read_namespaced_job(\n    kubernetes_credentials: KubernetesCredentials,\n    job_name: str,\n    namespace: Optional[str] = \"default\",\n    **kube_kwargs: Dict[str, Any],\n) -&gt; V1Job:\n\"\"\"Task for reading a namespaced Kubernetes job.\n\n    Args:\n        kubernetes_credentials: `KubernetesCredentials` block\n            holding authentication needed to generate the required API client.\n        job_name: The name of a job to read.\n        namespace: The Kubernetes namespace to read this job in.\n        **kube_kwargs: Optional extra keyword arguments to pass to the\n            Kubernetes API (e.g. `{\"pretty\": \"...\", \"dry_run\": \"...\"}`).\n\n    Raises:\n        ValueError: if `job_name` is `None`.\n\n    Returns:\n        A Kubernetes `V1Job` object.\n\n    Example:\n        Read \"my-job\" in the default namespace:\n        ```python\n        from prefect import flow\n        from prefect_kubernetes.credentials import KubernetesCredentials\n        from prefect_kubernetes.jobs import read_namespaced_job\n\n        @flow\n        def kubernetes_orchestrator():\n            v1_job_metadata = read_namespaced_job(\n                job_name=\"my-job\",\n                kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n            )\n        ```\n    \"\"\"\n    with kubernetes_credentials.get_client(\"batch\") as batch_v1_client:\n        return await run_sync_in_worker_thread(\n            batch_v1_client.read_namespaced_job,\n            name=job_name,\n            namespace=namespace,\n            **kube_kwargs,\n        )\n</code></pre>"},{"location":"jobs/#prefect_kubernetes.jobs.read_namespaced_job_status","title":"<code>read_namespaced_job_status</code>  <code>async</code>","text":"<p>Task for fetching status of a namespaced Kubernetes job.</p> <p>Parameters:</p> Name Type Description Default <code>kubernetes_credentials</code> <code>KubernetesCredentials</code> <p><code>KubernetesCredentials</code> block holding authentication needed to generate the required API client.</p> required <code>job_name</code> <code>str</code> <p>The name of a job to fetch status for.</p> required <code>namespace</code> <code>Optional[str]</code> <p>The Kubernetes namespace to fetch status of job in.</p> <code>'default'</code> <code>**kube_kwargs</code> <code>Dict[str, Any]</code> <p>Optional extra keyword arguments to pass to the Kubernetes API (e.g. <code>{\"pretty\": \"...\", \"dry_run\": \"...\"}</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>V1Job</code> <p>A Kubernetes <code>V1JobStatus</code> object.</p> Example <p>Fetch status of a job in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.jobs import read_namespaced_job_status\n\n@flow\ndef kubernetes_orchestrator():\n    v1_job_status = read_namespaced_job_status(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        job_name=\"my-job\",\n    )\n</code></pre></p> Source code in <code>prefect_kubernetes/jobs.py</code> <pre><code>@task\nasync def read_namespaced_job_status(\n    kubernetes_credentials: KubernetesCredentials,\n    job_name: str,\n    namespace: Optional[str] = \"default\",\n    **kube_kwargs: Dict[str, Any],\n) -&gt; V1Job:\n\"\"\"Task for fetching status of a namespaced Kubernetes job.\n\n    Args:\n        kubernetes_credentials: `KubernetesCredentials` block\n            holding authentication needed to generate the required API client.\n        job_name: The name of a job to fetch status for.\n        namespace: The Kubernetes namespace to fetch status of job in.\n        **kube_kwargs: Optional extra keyword arguments to pass to the\n            Kubernetes API (e.g. `{\"pretty\": \"...\", \"dry_run\": \"...\"}`).\n\n    Returns:\n        A Kubernetes `V1JobStatus` object.\n\n    Example:\n        Fetch status of a job in the default namespace:\n        ```python\n        from prefect import flow\n        from prefect_kubernetes.credentials import KubernetesCredentials\n        from prefect_kubernetes.jobs import read_namespaced_job_status\n\n        @flow\n        def kubernetes_orchestrator():\n            v1_job_status = read_namespaced_job_status(\n                kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n                job_name=\"my-job\",\n            )\n        ```\n    \"\"\"\n    with kubernetes_credentials.get_client(\"batch\") as batch_v1_client:\n        return await run_sync_in_worker_thread(\n            batch_v1_client.read_namespaced_job_status,\n            name=job_name,\n            namespace=namespace,\n            **kube_kwargs,\n        )\n</code></pre>"},{"location":"jobs/#prefect_kubernetes.jobs.replace_namespaced_job","title":"<code>replace_namespaced_job</code>  <code>async</code>","text":"<p>Task for replacing a namespaced Kubernetes job.</p> <p>Parameters:</p> Name Type Description Default <code>kubernetes_credentials</code> <code>KubernetesCredentials</code> <p><code>KubernetesCredentials</code> block holding authentication needed to generate the required API client.</p> required <code>job_name</code> <code>str</code> <p>The name of a job to replace.</p> required <code>new_job</code> <code>V1Job</code> <p>A Kubernetes <code>V1Job</code> specification.</p> required <code>namespace</code> <code>Optional[str]</code> <p>The Kubernetes namespace to replace this job in.</p> <code>'default'</code> <code>**kube_kwargs</code> <code>Dict[str, Any]</code> <p>Optional extra keyword arguments to pass to the Kubernetes API (e.g. <code>{\"pretty\": \"...\", \"dry_run\": \"...\"}</code>).</p> <code>{}</code> <p>Returns:</p> Type Description <code>V1Job</code> <p>A Kubernetes <code>V1Job</code> object.</p> Example <p>Replace \"my-job\" in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.jobs import replace_namespaced_job\n\n@flow\ndef kubernetes_orchestrator():\n    v1_job_metadata = replace_namespaced_job(\n        new_job=V1Job(metadata={\"labels\": {\"foo\": \"bar\"}}),\n        job_name=\"my-job\",\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n    )\n</code></pre></p> Source code in <code>prefect_kubernetes/jobs.py</code> <pre><code>@task\nasync def replace_namespaced_job(\n    kubernetes_credentials: KubernetesCredentials,\n    job_name: str,\n    new_job: V1Job,\n    namespace: Optional[str] = \"default\",\n    **kube_kwargs: Dict[str, Any],\n) -&gt; V1Job:\n\"\"\"Task for replacing a namespaced Kubernetes job.\n\n    Args:\n        kubernetes_credentials: `KubernetesCredentials` block\n            holding authentication needed to generate the required API client.\n        job_name: The name of a job to replace.\n        new_job: A Kubernetes `V1Job` specification.\n        namespace: The Kubernetes namespace to replace this job in.\n        **kube_kwargs: Optional extra keyword arguments to pass to the\n            Kubernetes API (e.g. `{\"pretty\": \"...\", \"dry_run\": \"...\"}`).\n\n    Returns:\n        A Kubernetes `V1Job` object.\n\n    Example:\n        Replace \"my-job\" in the default namespace:\n        ```python\n        from prefect import flow\n        from prefect_kubernetes.credentials import KubernetesCredentials\n        from prefect_kubernetes.jobs import replace_namespaced_job\n\n        @flow\n        def kubernetes_orchestrator():\n            v1_job_metadata = replace_namespaced_job(\n                new_job=V1Job(metadata={\"labels\": {\"foo\": \"bar\"}}),\n                job_name=\"my-job\",\n                kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n            )\n        ```\n    \"\"\"\n    with kubernetes_credentials.get_client(\"batch\") as batch_v1_client:\n        return await run_sync_in_worker_thread(\n            batch_v1_client.replace_namespaced_job,\n            name=job_name,\n            body=new_job,\n            namespace=namespace,\n            **kube_kwargs,\n        )\n</code></pre>"},{"location":"pods/","title":"Pods","text":""},{"location":"pods/#prefect_kubernetes.pods","title":"<code>prefect_kubernetes.pods</code>","text":"<p>Module for interacting with Kubernetes pods from Prefect flows.</p>"},{"location":"pods/#prefect_kubernetes.pods-classes","title":"Classes","text":""},{"location":"pods/#prefect_kubernetes.pods-functions","title":"Functions","text":""},{"location":"pods/#prefect_kubernetes.pods.create_namespaced_pod","title":"<code>create_namespaced_pod</code>  <code>async</code>","text":"<p>Create a Kubernetes pod in a given namespace.</p> <p>Parameters:</p> Name Type Description Default <code>kubernetes_credentials</code> <code>KubernetesCredentials</code> <p><code>KubernetesCredentials</code> block for creating authenticated Kubernetes API clients.</p> required <code>new_pod</code> <code>V1Pod</code> <p>A Kubernetes <code>V1Pod</code> specification.</p> required <code>namespace</code> <code>Optional[str]</code> <p>The Kubernetes namespace to create this pod in.</p> <code>'default'</code> <code>**kube_kwargs</code> <code>Dict[str, Any]</code> <p>Optional extra keyword arguments to pass to the Kubernetes API.</p> <code>{}</code> <p>Returns:</p> Type Description <code>V1Pod</code> <p>A Kubernetes <code>V1Pod</code> object.</p> Example <p>Create a pod in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.pods import create_namespaced_pod\nfrom kubernetes.client.models import V1Pod\n\n@flow\ndef kubernetes_orchestrator():\n    v1_pod_metadata = create_namespaced_pod(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        new_pod=V1Pod(metadata={\"name\": \"test-pod\"}),\n    )\n</code></pre></p> Source code in <code>prefect_kubernetes/pods.py</code> <pre><code>@task\nasync def create_namespaced_pod(\n    kubernetes_credentials: KubernetesCredentials,\n    new_pod: V1Pod,\n    namespace: Optional[str] = \"default\",\n    **kube_kwargs: Dict[str, Any],\n) -&gt; V1Pod:\n\"\"\"Create a Kubernetes pod in a given namespace.\n\n    Args:\n        kubernetes_credentials: `KubernetesCredentials` block for creating\n            authenticated Kubernetes API clients.\n        new_pod: A Kubernetes `V1Pod` specification.\n        namespace: The Kubernetes namespace to create this pod in.\n        **kube_kwargs: Optional extra keyword arguments to pass to the Kubernetes API.\n\n    Returns:\n        A Kubernetes `V1Pod` object.\n\n    Example:\n        Create a pod in the default namespace:\n        ```python\n        from prefect import flow\n        from prefect_kubernetes.credentials import KubernetesCredentials\n        from prefect_kubernetes.pods import create_namespaced_pod\n        from kubernetes.client.models import V1Pod\n\n        @flow\n        def kubernetes_orchestrator():\n            v1_pod_metadata = create_namespaced_pod(\n                kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n                new_pod=V1Pod(metadata={\"name\": \"test-pod\"}),\n            )\n        ```\n    \"\"\"\n    with kubernetes_credentials.get_client(\"core\") as core_v1_client:\n\n        return await run_sync_in_worker_thread(\n            core_v1_client.create_namespaced_pod,\n            namespace=namespace,\n            body=new_pod,\n            **kube_kwargs,\n        )\n</code></pre>"},{"location":"pods/#prefect_kubernetes.pods.delete_namespaced_pod","title":"<code>delete_namespaced_pod</code>  <code>async</code>","text":"<p>Delete a Kubernetes pod in a given namespace.</p> <p>Parameters:</p> Name Type Description Default <code>kubernetes_credentials</code> <code>KubernetesCredentials</code> <p><code>KubernetesCredentials</code> block for creating authenticated Kubernetes API clients.</p> required <code>pod_name</code> <code>str</code> <p>The name of the pod to delete.</p> required <code>delete_options</code> <code>Optional[V1DeleteOptions]</code> <p>A Kubernetes <code>V1DeleteOptions</code> object.</p> <code>None</code> <code>namespace</code> <code>Optional[str]</code> <p>The Kubernetes namespace to delete this pod from.</p> <code>'default'</code> <code>**kube_kwargs</code> <code>Dict[str, Any]</code> <p>Optional extra keyword arguments to pass to the Kubernetes API.</p> <code>{}</code> <p>Returns:</p> Type Description <code>V1Pod</code> <p>A Kubernetes <code>V1Pod</code> object.</p> Example <p>Delete a pod in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.pods import delete_namespaced_pod\nfrom kubernetes.client.models import V1DeleteOptions\n\n@flow\ndef kubernetes_orchestrator():\n    v1_pod_metadata = delete_namespaced_pod(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        pod_name=\"test-pod\",\n        delete_options=V1DeleteOptions(grace_period_seconds=0),\n    )\n</code></pre></p> Source code in <code>prefect_kubernetes/pods.py</code> <pre><code>@task\nasync def delete_namespaced_pod(\n    kubernetes_credentials: KubernetesCredentials,\n    pod_name: str,\n    delete_options: Optional[V1DeleteOptions] = None,\n    namespace: Optional[str] = \"default\",\n    **kube_kwargs: Dict[str, Any],\n) -&gt; V1Pod:\n\"\"\"Delete a Kubernetes pod in a given namespace.\n\n    Args:\n        kubernetes_credentials: `KubernetesCredentials` block for creating\n            authenticated Kubernetes API clients.\n        pod_name: The name of the pod to delete.\n        delete_options: A Kubernetes `V1DeleteOptions` object.\n        namespace: The Kubernetes namespace to delete this pod from.\n        **kube_kwargs: Optional extra keyword arguments to pass to the Kubernetes API.\n\n    Returns:\n        A Kubernetes `V1Pod` object.\n\n    Example:\n        Delete a pod in the default namespace:\n        ```python\n        from prefect import flow\n        from prefect_kubernetes.credentials import KubernetesCredentials\n        from prefect_kubernetes.pods import delete_namespaced_pod\n        from kubernetes.client.models import V1DeleteOptions\n\n        @flow\n        def kubernetes_orchestrator():\n            v1_pod_metadata = delete_namespaced_pod(\n                kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n                pod_name=\"test-pod\",\n                delete_options=V1DeleteOptions(grace_period_seconds=0),\n            )\n        ```\n    \"\"\"\n    with kubernetes_credentials.get_client(\"core\") as core_v1_client:\n\n        return await run_sync_in_worker_thread(\n            core_v1_client.delete_namespaced_pod,\n            pod_name,\n            body=delete_options,\n            namespace=namespace,\n            **kube_kwargs,\n        )\n</code></pre>"},{"location":"pods/#prefect_kubernetes.pods.list_namespaced_pod","title":"<code>list_namespaced_pod</code>  <code>async</code>","text":"<p>List all pods in a given namespace.</p> <p>Parameters:</p> Name Type Description Default <code>kubernetes_credentials</code> <code>KubernetesCredentials</code> <p><code>KubernetesCredentials</code> block for creating authenticated Kubernetes API clients.</p> required <code>namespace</code> <code>Optional[str]</code> <p>The Kubernetes namespace to list pods from.</p> <code>'default'</code> <code>**kube_kwargs</code> <code>Dict[str, Any]</code> <p>Optional extra keyword arguments to pass to the Kubernetes API.</p> <code>{}</code> <p>Returns:</p> Type Description <code>V1PodList</code> <p>A Kubernetes <code>V1PodList</code> object.</p> Example <p>List all pods in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.pods import list_namespaced_pod\n\n@flow\ndef kubernetes_orchestrator():\n    v1_pod_list = list_namespaced_pod(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\")\n    )\n</code></pre></p> Source code in <code>prefect_kubernetes/pods.py</code> <pre><code>@task\nasync def list_namespaced_pod(\n    kubernetes_credentials: KubernetesCredentials,\n    namespace: Optional[str] = \"default\",\n    **kube_kwargs: Dict[str, Any],\n) -&gt; V1PodList:\n\"\"\"List all pods in a given namespace.\n\n    Args:\n        kubernetes_credentials: `KubernetesCredentials` block for creating\n            authenticated Kubernetes API clients.\n        namespace: The Kubernetes namespace to list pods from.\n        **kube_kwargs: Optional extra keyword arguments to pass to the Kubernetes API.\n\n    Returns:\n        A Kubernetes `V1PodList` object.\n\n    Example:\n        List all pods in the default namespace:\n        ```python\n        from prefect import flow\n        from prefect_kubernetes.credentials import KubernetesCredentials\n        from prefect_kubernetes.pods import list_namespaced_pod\n\n        @flow\n        def kubernetes_orchestrator():\n            v1_pod_list = list_namespaced_pod(\n                kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\")\n            )\n        ```\n    \"\"\"\n    with kubernetes_credentials.get_client(\"core\") as core_v1_client:\n\n        return await run_sync_in_worker_thread(\n            core_v1_client.list_namespaced_pod, namespace=namespace, **kube_kwargs\n        )\n</code></pre>"},{"location":"pods/#prefect_kubernetes.pods.patch_namespaced_pod","title":"<code>patch_namespaced_pod</code>  <code>async</code>","text":"<p>Patch a Kubernetes pod in a given namespace.</p> <p>Parameters:</p> Name Type Description Default <code>kubernetes_credentials</code> <code>KubernetesCredentials</code> <p><code>KubernetesCredentials</code> block for creating authenticated Kubernetes API clients.</p> required <code>pod_name</code> <code>str</code> <p>The name of the pod to patch.</p> required <code>pod_updates</code> <code>V1Pod</code> <p>A Kubernetes <code>V1Pod</code> object.</p> required <code>namespace</code> <code>Optional[str]</code> <p>The Kubernetes namespace to patch this pod in.</p> <code>'default'</code> <code>**kube_kwargs</code> <code>Dict[str, Any]</code> <p>Optional extra keyword arguments to pass to the Kubernetes API.</p> <code>{}</code> <p>Returns:</p> Type Description <code>V1Pod</code> <p>A Kubernetes <code>V1Pod</code> object.</p> Example <p>Patch a pod in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.pods import patch_namespaced_pod\nfrom kubernetes.client.models import V1Pod\n\n@flow\ndef kubernetes_orchestrator():\n    v1_pod_metadata = patch_namespaced_pod(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        pod_name=\"test-pod\",\n        pod_updates=V1Pod(metadata={\"labels\": {\"foo\": \"bar\"}}),\n    )\n</code></pre></p> Source code in <code>prefect_kubernetes/pods.py</code> <pre><code>@task\nasync def patch_namespaced_pod(\n    kubernetes_credentials: KubernetesCredentials,\n    pod_name: str,\n    pod_updates: V1Pod,\n    namespace: Optional[str] = \"default\",\n    **kube_kwargs: Dict[str, Any],\n) -&gt; V1Pod:\n\"\"\"Patch a Kubernetes pod in a given namespace.\n\n    Args:\n        kubernetes_credentials: `KubernetesCredentials` block for creating\n            authenticated Kubernetes API clients.\n        pod_name: The name of the pod to patch.\n        pod_updates: A Kubernetes `V1Pod` object.\n        namespace: The Kubernetes namespace to patch this pod in.\n        **kube_kwargs: Optional extra keyword arguments to pass to the Kubernetes API.\n\n    Returns:\n        A Kubernetes `V1Pod` object.\n\n    Example:\n        Patch a pod in the default namespace:\n        ```python\n        from prefect import flow\n        from prefect_kubernetes.credentials import KubernetesCredentials\n        from prefect_kubernetes.pods import patch_namespaced_pod\n        from kubernetes.client.models import V1Pod\n\n        @flow\n        def kubernetes_orchestrator():\n            v1_pod_metadata = patch_namespaced_pod(\n                kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n                pod_name=\"test-pod\",\n                pod_updates=V1Pod(metadata={\"labels\": {\"foo\": \"bar\"}}),\n            )\n        ```\n    \"\"\"\n    with kubernetes_credentials.get_client(\"core\") as core_v1_client:\n\n        return await run_sync_in_worker_thread(\n            core_v1_client.patch_namespaced_pod,\n            name=pod_name,\n            namespace=namespace,\n            body=pod_updates,\n            **kube_kwargs,\n        )\n</code></pre>"},{"location":"pods/#prefect_kubernetes.pods.read_namespaced_pod","title":"<code>read_namespaced_pod</code>  <code>async</code>","text":"<p>Read information on a Kubernetes pod in a given namespace.</p> <p>Parameters:</p> Name Type Description Default <code>kubernetes_credentials</code> <code>KubernetesCredentials</code> <p><code>KubernetesCredentials</code> block for creating authenticated Kubernetes API clients.</p> required <code>pod_name</code> <code>str</code> <p>The name of the pod to read.</p> required <code>namespace</code> <code>Optional[str]</code> <p>The Kubernetes namespace to read this pod from.</p> <code>'default'</code> <code>**kube_kwargs</code> <code>Dict[str, Any]</code> <p>Optional extra keyword arguments to pass to the Kubernetes API.</p> <code>{}</code> <p>Returns:</p> Type Description <code>V1Pod</code> <p>A Kubernetes <code>V1Pod</code> object.</p> Example <p>Read a pod in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\n\n@flow\ndef kubernetes_orchestrator():\n    v1_pod_metadata = read_namespaced_pod(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        pod_name=\"test-pod\"\n    )\n</code></pre></p> Source code in <code>prefect_kubernetes/pods.py</code> <pre><code>@task\nasync def read_namespaced_pod(\n    kubernetes_credentials: KubernetesCredentials,\n    pod_name: str,\n    namespace: Optional[str] = \"default\",\n    **kube_kwargs: Dict[str, Any],\n) -&gt; V1Pod:\n\"\"\"Read information on a Kubernetes pod in a given namespace.\n\n    Args:\n        kubernetes_credentials: `KubernetesCredentials` block for creating\n            authenticated Kubernetes API clients.\n        pod_name: The name of the pod to read.\n        namespace: The Kubernetes namespace to read this pod from.\n        **kube_kwargs: Optional extra keyword arguments to pass to the Kubernetes API.\n\n    Returns:\n        A Kubernetes `V1Pod` object.\n\n    Example:\n        Read a pod in the default namespace:\n        ```python\n        from prefect import flow\n        from prefect_kubernetes.credentials import KubernetesCredentials\n\n        @flow\n        def kubernetes_orchestrator():\n            v1_pod_metadata = read_namespaced_pod(\n                kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n                pod_name=\"test-pod\"\n            )\n        ```\n    \"\"\"\n    with kubernetes_credentials.get_client(\"core\") as core_v1_client:\n\n        return await run_sync_in_worker_thread(\n            core_v1_client.read_namespaced_pod,\n            name=pod_name,\n            namespace=namespace,\n            **kube_kwargs,\n        )\n</code></pre>"},{"location":"pods/#prefect_kubernetes.pods.read_namespaced_pod_log","title":"<code>read_namespaced_pod_log</code>  <code>async</code>","text":"<p>Read logs from a Kubernetes pod in a given namespace.</p> <p>If <code>print_func</code> is provided, the logs will be streamed using that function. If the pod is no longer running, logs generated up to that point will be returned.</p> <p>Parameters:</p> Name Type Description Default <code>kubernetes_credentials</code> <code>KubernetesCredentials</code> <p><code>KubernetesCredentials</code> block for creating authenticated Kubernetes API clients.</p> required <code>pod_name</code> <code>str</code> <p>The name of the pod to read logs from.</p> required <code>container</code> <code>str</code> <p>The name of the container to read logs from.</p> required <code>namespace</code> <code>Optional[str]</code> <p>The Kubernetes namespace to read this pod from.</p> <code>'default'</code> <code>print_func</code> <code>Optional[Callable]</code> <p>If provided, it will stream the pod logs by calling <code>print_func</code> for every line and returning <code>None</code>. If not provided, the current pod logs will be returned immediately.</p> <code>None</code> <code>**kube_kwargs</code> <code>Dict[str, Any]</code> <p>Optional extra keyword arguments to pass to the Kubernetes API.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Union[str, None]</code> <p>A string containing the logs from the pod's container.</p> Example <p>Read logs from a pod in the default namespace: <pre><code>from prefect import flow, get_run_logger\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.pods import read_namespaced_pod_logs\n\n@flow\ndef kubernetes_orchestrator():\n    logger = get_run_logger()\n\n    pod_logs = read_namespaced_pod_logs(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        pod_name=\"test-pod\",\n        container=\"test-container\",\n        print_func=logger.info\n    )\n</code></pre></p> Source code in <code>prefect_kubernetes/pods.py</code> <pre><code>@task\nasync def read_namespaced_pod_log(\n    kubernetes_credentials: KubernetesCredentials,\n    pod_name: str,\n    container: str,\n    namespace: Optional[str] = \"default\",\n    print_func: Optional[Callable] = None,\n    **kube_kwargs: Dict[str, Any],\n) -&gt; Union[str, None]:\n\"\"\"Read logs from a Kubernetes pod in a given namespace.\n\n    If `print_func` is provided, the logs will be streamed using that function.\n    If the pod is no longer running, logs generated up to that point will be returned.\n\n    Args:\n        kubernetes_credentials: `KubernetesCredentials` block for creating\n            authenticated Kubernetes API clients.\n        pod_name: The name of the pod to read logs from.\n        container: The name of the container to read logs from.\n        namespace: The Kubernetes namespace to read this pod from.\n        print_func: If provided, it will stream the pod logs by calling `print_func`\n            for every line and returning `None`. If not provided, the current pod\n            logs will be returned immediately.\n        **kube_kwargs: Optional extra keyword arguments to pass to the Kubernetes API.\n\n    Returns:\n        A string containing the logs from the pod's container.\n\n    Example:\n        Read logs from a pod in the default namespace:\n        ```python\n        from prefect import flow, get_run_logger\n        from prefect_kubernetes.credentials import KubernetesCredentials\n        from prefect_kubernetes.pods import read_namespaced_pod_logs\n\n        @flow\n        def kubernetes_orchestrator():\n            logger = get_run_logger()\n\n            pod_logs = read_namespaced_pod_logs(\n                kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n                pod_name=\"test-pod\",\n                container=\"test-container\",\n                print_func=logger.info\n            )\n        ```\n    \"\"\"\n    with kubernetes_credentials.get_client(\"core\") as core_v1_client:\n\n        if print_func is not None:\n            # should no longer need to manually refresh on ApiException.status == 410\n            # as of https://github.com/kubernetes-client/python-base/pull/133\n            for log_line in Watch().stream(\n                core_v1_client.read_namespaced_pod_log,\n                name=pod_name,\n                namespace=namespace,\n                container=container,\n            ):\n                print_func(log_line)\n\n        return await run_sync_in_worker_thread(\n            core_v1_client.read_namespaced_pod_log,\n            name=pod_name,\n            namespace=namespace,\n            container=container,\n            **kube_kwargs,\n        )\n</code></pre>"},{"location":"pods/#prefect_kubernetes.pods.replace_namespaced_pod","title":"<code>replace_namespaced_pod</code>  <code>async</code>","text":"<p>Replace a Kubernetes pod in a given namespace.</p> <p>Parameters:</p> Name Type Description Default <code>kubernetes_credentials</code> <code>KubernetesCredentials</code> <p><code>KubernetesCredentials</code> block for creating authenticated Kubernetes API clients.</p> required <code>pod_name</code> <code>str</code> <p>The name of the pod to replace.</p> required <code>new_pod</code> <code>V1Pod</code> <p>A Kubernetes <code>V1Pod</code> object.</p> required <code>namespace</code> <code>Optional[str]</code> <p>The Kubernetes namespace to replace this pod in.</p> <code>'default'</code> <code>**kube_kwargs</code> <code>Dict[str, Any]</code> <p>Optional extra keyword arguments to pass to the Kubernetes API.</p> <code>{}</code> <p>Returns:</p> Type Description <code>V1Pod</code> <p>A Kubernetes <code>V1Pod</code> object.</p> Example <p>Replace a pod in the default namespace: <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.pods import replace_namespaced_pod\nfrom kubernetes.client.models import V1Pod\n\n@flow\ndef kubernetes_orchestrator():\n    v1_pod_metadata = replace_namespaced_pod(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        pod_name=\"test-pod\",\n        new_pod=V1Pod(metadata={\"labels\": {\"foo\": \"bar\"}})\n    )\n</code></pre></p> Source code in <code>prefect_kubernetes/pods.py</code> <pre><code>@task\nasync def replace_namespaced_pod(\n    kubernetes_credentials: KubernetesCredentials,\n    pod_name: str,\n    new_pod: V1Pod,\n    namespace: Optional[str] = \"default\",\n    **kube_kwargs: Dict[str, Any],\n) -&gt; V1Pod:\n\"\"\"Replace a Kubernetes pod in a given namespace.\n\n    Args:\n        kubernetes_credentials: `KubernetesCredentials` block for creating\n            authenticated Kubernetes API clients.\n        pod_name: The name of the pod to replace.\n        new_pod: A Kubernetes `V1Pod` object.\n        namespace: The Kubernetes namespace to replace this pod in.\n        **kube_kwargs: Optional extra keyword arguments to pass to the Kubernetes API.\n\n    Returns:\n        A Kubernetes `V1Pod` object.\n\n    Example:\n        Replace a pod in the default namespace:\n        ```python\n        from prefect import flow\n        from prefect_kubernetes.credentials import KubernetesCredentials\n        from prefect_kubernetes.pods import replace_namespaced_pod\n        from kubernetes.client.models import V1Pod\n\n        @flow\n        def kubernetes_orchestrator():\n            v1_pod_metadata = replace_namespaced_pod(\n                kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n                pod_name=\"test-pod\",\n                new_pod=V1Pod(metadata={\"labels\": {\"foo\": \"bar\"}})\n            )\n        ```\n    \"\"\"\n    with kubernetes_credentials.get_client(\"core\") as core_v1_client:\n\n        return await run_sync_in_worker_thread(\n            core_v1_client.replace_namespaced_pod,\n            body=new_pod,\n            name=pod_name,\n            namespace=namespace,\n            **kube_kwargs,\n        )\n</code></pre>"},{"location":"services/","title":"Services","text":""},{"location":"services/#prefect_kubernetes.services","title":"<code>prefect_kubernetes.services</code>","text":"<p>Tasks for working with Kubernetes services.</p>"},{"location":"services/#prefect_kubernetes.services-classes","title":"Classes","text":""},{"location":"services/#prefect_kubernetes.services-functions","title":"Functions","text":""},{"location":"services/#prefect_kubernetes.services.create_namespaced_service","title":"<code>create_namespaced_service</code>  <code>async</code>","text":"<p>Create a namespaced Kubernetes service.</p> <p>Parameters:</p> Name Type Description Default <code>kubernetes_credentials</code> <code>KubernetesCredentials</code> <p>A <code>KubernetesCredentials</code> block used to generate a <code>CoreV1Api</code> client.</p> required <code>new_service</code> <code>V1Service</code> <p>A <code>V1Service</code> object representing the service to create.</p> required <code>namespace</code> <code>Optional[str]</code> <p>The namespace to create the service in.</p> <code>'default'</code> <code>**kube_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>Additional keyword arguments to pass to the <code>CoreV1Api</code> method call.</p> <code>{}</code> <p>Returns:</p> Type Description <code>V1Service</code> <p>A <code>V1Service</code> representing the created service.</p> Example <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.services import create_namespaced_service\nfrom kubernetes.client.models import V1Service\n\n@flow\ndef create_service_flow():\n    v1_service = create_namespaced_service(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        new_service=V1Service(metadata={...}, spec={...}),\n    )\n</code></pre> Source code in <code>prefect_kubernetes/services.py</code> <pre><code>@task\nasync def create_namespaced_service(\n    kubernetes_credentials: KubernetesCredentials,\n    new_service: V1Service,\n    namespace: Optional[str] = \"default\",\n    **kube_kwargs: Optional[Dict[str, Any]],\n) -&gt; V1Service:\n\"\"\"Create a namespaced Kubernetes service.\n\n    Args:\n        kubernetes_credentials: A `KubernetesCredentials` block used to generate a\n            `CoreV1Api` client.\n        new_service: A `V1Service` object representing the service to create.\n        namespace: The namespace to create the service in.\n        **kube_kwargs: Additional keyword arguments to pass to the `CoreV1Api`\n            method call.\n\n    Returns:\n        A `V1Service` representing the created service.\n\n    Example:\n        ```python\n        from prefect import flow\n        from prefect_kubernetes.credentials import KubernetesCredentials\n        from prefect_kubernetes.services import create_namespaced_service\n        from kubernetes.client.models import V1Service\n\n        @flow\n        def create_service_flow():\n            v1_service = create_namespaced_service(\n                kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n                new_service=V1Service(metadata={...}, spec={...}),\n            )\n        ```\n    \"\"\"\n    with kubernetes_credentials.get_client(\"core\") as core_v1_client:\n\n        return await run_sync_in_worker_thread(\n            core_v1_client.create_namespaced_service,\n            body=new_service,\n            namespace=namespace,\n            **kube_kwargs,\n        )\n</code></pre>"},{"location":"services/#prefect_kubernetes.services.delete_namespaced_service","title":"<code>delete_namespaced_service</code>  <code>async</code>","text":"<p>Delete a namespaced Kubernetes service.</p> <p>Parameters:</p> Name Type Description Default <code>kubernetes_credentials</code> <code>KubernetesCredentials</code> <p><code>KubernetesCredentials</code> block for creating authenticated Kubernetes API clients.</p> required <code>service_name</code> <code>str</code> <p>The name of the service to delete.</p> required <code>delete_options</code> <code>Optional[V1DeleteOptions]</code> <p>A <code>V1DeleteOptions</code> object representing the options to delete the service with.</p> <code>None</code> <code>namespace</code> <code>Optional[str]</code> <p>The namespace to delete the service from.</p> <code>'default'</code> <code>**kube_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>Optional extra keyword arguments to pass to the Kubernetes API.</p> <code>{}</code> <p>Returns:</p> Type Description <code>V1Service</code> <p>A <code>V1Service</code> representing the deleted service.</p> Example <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.services import delete_namespaced_service\n\n@flow\ndef kubernetes_orchestrator():\n    delete_namespaced_service(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        service_name=\"my-service\",\n        namespace=\"my-namespace\",\n    )\n</code></pre> Source code in <code>prefect_kubernetes/services.py</code> <pre><code>@task\nasync def delete_namespaced_service(\n    kubernetes_credentials: KubernetesCredentials,\n    service_name: str,\n    delete_options: Optional[V1DeleteOptions] = None,\n    namespace: Optional[str] = \"default\",\n    **kube_kwargs: Optional[Dict[str, Any]],\n) -&gt; V1Service:\n\"\"\"Delete a namespaced Kubernetes service.\n\n    Args:\n        kubernetes_credentials: `KubernetesCredentials` block for creating\n            authenticated Kubernetes API clients.\n        service_name: The name of the service to delete.\n        delete_options: A `V1DeleteOptions` object representing the options to\n            delete the service with.\n        namespace: The namespace to delete the service from.\n        **kube_kwargs: Optional extra keyword arguments to pass to the Kubernetes API.\n\n    Returns:\n        A `V1Service` representing the deleted service.\n\n    Example:\n        ```python\n        from prefect import flow\n        from prefect_kubernetes.credentials import KubernetesCredentials\n        from prefect_kubernetes.services import delete_namespaced_service\n\n        @flow\n        def kubernetes_orchestrator():\n            delete_namespaced_service(\n                kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n                service_name=\"my-service\",\n                namespace=\"my-namespace\",\n            )\n        ```\n    \"\"\"\n    with kubernetes_credentials.get_client(\"core\") as core_v1_client:\n\n        return await run_sync_in_worker_thread(\n            core_v1_client.delete_namespaced_service,\n            name=service_name,\n            namespace=namespace,\n            body=delete_options,\n            **kube_kwargs,\n        )\n</code></pre>"},{"location":"services/#prefect_kubernetes.services.list_namespaced_service","title":"<code>list_namespaced_service</code>  <code>async</code>","text":"<p>List namespaced Kubernetes services.</p> <p>Parameters:</p> Name Type Description Default <code>kubernetes_credentials</code> <code>KubernetesCredentials</code> <p><code>KubernetesCredentials</code> block for creating authenticated Kubernetes API clients.</p> required <code>namespace</code> <code>Optional[str]</code> <p>The namespace to list services from.</p> <code>'default'</code> <code>**kube_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>Optional extra keyword arguments to pass to the Kubernetes API.</p> <code>{}</code> <p>Returns:</p> Type Description <code>V1ServiceList</code> <p>A <code>V1ServiceList</code> representing the list of services in the given namespace.</p> Example <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.services import list_namespaced_service\n\n@flow\ndef kubernetes_orchestrator():\n    list_namespaced_service(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        namespace=\"my-namespace\",\n    )\n</code></pre> Source code in <code>prefect_kubernetes/services.py</code> <pre><code>@task\nasync def list_namespaced_service(\n    kubernetes_credentials: KubernetesCredentials,\n    namespace: Optional[str] = \"default\",\n    **kube_kwargs: Optional[Dict[str, Any]],\n) -&gt; V1ServiceList:\n\"\"\"List namespaced Kubernetes services.\n\n    Args:\n        kubernetes_credentials: `KubernetesCredentials` block for creating\n            authenticated Kubernetes API clients.\n        namespace: The namespace to list services from.\n        **kube_kwargs: Optional extra keyword arguments to pass to the Kubernetes API.\n\n    Returns:\n        A `V1ServiceList` representing the list of services in the given namespace.\n\n    Example:\n        ```python\n        from prefect import flow\n        from prefect_kubernetes.credentials import KubernetesCredentials\n        from prefect_kubernetes.services import list_namespaced_service\n\n        @flow\n        def kubernetes_orchestrator():\n            list_namespaced_service(\n                kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n                namespace=\"my-namespace\",\n            )\n        ```\n    \"\"\"\n    with kubernetes_credentials.get_client(\"core\") as core_v1_client:\n\n        return await run_sync_in_worker_thread(\n            core_v1_client.list_namespaced_service,\n            namespace=namespace,\n            **kube_kwargs,\n        )\n</code></pre>"},{"location":"services/#prefect_kubernetes.services.patch_namespaced_service","title":"<code>patch_namespaced_service</code>  <code>async</code>","text":"<p>Patch a namespaced Kubernetes service.</p> <p>Parameters:</p> Name Type Description Default <code>kubernetes_credentials</code> <code>KubernetesCredentials</code> <p><code>KubernetesCredentials</code> block for creating authenticated Kubernetes API clients.</p> required <code>service_name</code> <code>str</code> <p>The name of the service to patch.</p> required <code>service_updates</code> <code>V1Service</code> <p>A <code>V1Service</code> object representing patches to <code>service_name</code>.</p> required <code>namespace</code> <code>Optional[str]</code> <p>The namespace to patch the service in.</p> <code>'default'</code> <code>**kube_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>Optional extra keyword arguments to pass to the Kubernetes API.</p> <code>{}</code> <p>Returns:</p> Type Description <code>V1Service</code> <p>A <code>V1Service</code> representing the patched service.</p> Example <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.services import patch_namespaced_service\nfrom kubernetes.client.models import V1Service\n\n@flow\ndef kubernetes_orchestrator():\n    patch_namespaced_service(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        service_name=\"my-service\",\n        new_service=V1Service(metadata={...}, spec={...}),\n        namespace=\"my-namespace\",\n    )\n</code></pre> Source code in <code>prefect_kubernetes/services.py</code> <pre><code>@task\nasync def patch_namespaced_service(\n    kubernetes_credentials: KubernetesCredentials,\n    service_name: str,\n    service_updates: V1Service,\n    namespace: Optional[str] = \"default\",\n    **kube_kwargs: Optional[Dict[str, Any]],\n) -&gt; V1Service:\n\"\"\"Patch a namespaced Kubernetes service.\n\n    Args:\n        kubernetes_credentials: `KubernetesCredentials` block for creating\n            authenticated Kubernetes API clients.\n        service_name: The name of the service to patch.\n        service_updates: A `V1Service` object representing patches to `service_name`.\n        namespace: The namespace to patch the service in.\n        **kube_kwargs: Optional extra keyword arguments to pass to the Kubernetes API.\n\n    Returns:\n        A `V1Service` representing the patched service.\n\n    Example:\n        ```python\n        from prefect import flow\n        from prefect_kubernetes.credentials import KubernetesCredentials\n        from prefect_kubernetes.services import patch_namespaced_service\n        from kubernetes.client.models import V1Service\n\n        @flow\n        def kubernetes_orchestrator():\n            patch_namespaced_service(\n                kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n                service_name=\"my-service\",\n                new_service=V1Service(metadata={...}, spec={...}),\n                namespace=\"my-namespace\",\n            )\n        ```\n    \"\"\"\n    with kubernetes_credentials.get_client(\"core\") as core_v1_client:\n\n        return await run_sync_in_worker_thread(\n            core_v1_client.patch_namespaced_service,\n            name=service_name,\n            body=service_updates,\n            namespace=namespace,\n            **kube_kwargs,\n        )\n</code></pre>"},{"location":"services/#prefect_kubernetes.services.read_namespaced_service","title":"<code>read_namespaced_service</code>  <code>async</code>","text":"<p>Read a namespaced Kubernetes service.</p> <p>Parameters:</p> Name Type Description Default <code>kubernetes_credentials</code> <code>KubernetesCredentials</code> <p><code>KubernetesCredentials</code> block for creating authenticated Kubernetes API clients.</p> required <code>service_name</code> <code>str</code> <p>The name of the service to read.</p> required <code>namespace</code> <code>Optional[str]</code> <p>The namespace to read the service from.</p> <code>'default'</code> <code>**kube_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>Optional extra keyword arguments to pass to the Kubernetes API.</p> <code>{}</code> <p>Returns:</p> Type Description <code>V1Service</code> <p>A <code>V1Service</code> object representing the service.</p> Example <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.services import read_namespaced_service\n\n@flow\ndef kubernetes_orchestrator():\n    read_namespaced_service(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        service_name=\"my-service\",\n        namespace=\"my-namespace\",\n    )\n</code></pre> Source code in <code>prefect_kubernetes/services.py</code> <pre><code>@task\nasync def read_namespaced_service(\n    kubernetes_credentials: KubernetesCredentials,\n    service_name: str,\n    namespace: Optional[str] = \"default\",\n    **kube_kwargs: Optional[Dict[str, Any]],\n) -&gt; V1Service:\n\"\"\"Read a namespaced Kubernetes service.\n\n    Args:\n        kubernetes_credentials: `KubernetesCredentials` block for creating\n            authenticated Kubernetes API clients.\n        service_name: The name of the service to read.\n        namespace: The namespace to read the service from.\n        **kube_kwargs: Optional extra keyword arguments to pass to the Kubernetes API.\n\n    Returns:\n        A `V1Service` object representing the service.\n\n    Example:\n        ```python\n        from prefect import flow\n        from prefect_kubernetes.credentials import KubernetesCredentials\n        from prefect_kubernetes.services import read_namespaced_service\n\n        @flow\n        def kubernetes_orchestrator():\n            read_namespaced_service(\n                kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n                service_name=\"my-service\",\n                namespace=\"my-namespace\",\n            )\n        ```\n    \"\"\"\n    with kubernetes_credentials.get_client(\"core\") as core_v1_client:\n\n        return await run_sync_in_worker_thread(\n            core_v1_client.read_namespaced_service,\n            name=service_name,\n            namespace=namespace,\n            **kube_kwargs,\n        )\n</code></pre>"},{"location":"services/#prefect_kubernetes.services.replace_namespaced_service","title":"<code>replace_namespaced_service</code>  <code>async</code>","text":"<p>Replace a namespaced Kubernetes service.</p> <p>Parameters:</p> Name Type Description Default <code>kubernetes_credentials</code> <code>KubernetesCredentials</code> <p><code>KubernetesCredentials</code> block for creating authenticated Kubernetes API clients.</p> required <code>service_name</code> <code>str</code> <p>The name of the service to replace.</p> required <code>new_service</code> <code>V1Service</code> <p>A <code>V1Service</code> object representing the new service.</p> required <code>namespace</code> <code>Optional[str]</code> <p>The namespace to replace the service in.</p> <code>'default'</code> <code>**kube_kwargs</code> <code>Optional[Dict[str, Any]]</code> <p>Optional extra keyword arguments to pass to the Kubernetes API.</p> <code>{}</code> <p>Returns:</p> Type Description <code>V1Service</code> <p>A <code>V1Service</code> representing the new service.</p> Example <pre><code>from prefect import flow\nfrom prefect_kubernetes.credentials import KubernetesCredentials\nfrom prefect_kubernetes.services import replace_namespaced_service\nfrom kubernetes.client.models import V1Service\n\n@flow\ndef kubernetes_orchestrator():\n    replace_namespaced_service(\n        kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n        service_name=\"my-service\",\n        new_service=V1Service(metadata={...}, spec={...}),\n        namespace=\"my-namespace\",\n    )\n</code></pre> Source code in <code>prefect_kubernetes/services.py</code> <pre><code>@task\nasync def replace_namespaced_service(\n    kubernetes_credentials: KubernetesCredentials,\n    service_name: str,\n    new_service: V1Service,\n    namespace: Optional[str] = \"default\",\n    **kube_kwargs: Optional[Dict[str, Any]],\n) -&gt; V1Service:\n\"\"\"Replace a namespaced Kubernetes service.\n\n    Args:\n        kubernetes_credentials: `KubernetesCredentials` block for creating\n            authenticated Kubernetes API clients.\n        service_name: The name of the service to replace.\n        new_service: A `V1Service` object representing the new service.\n        namespace: The namespace to replace the service in.\n        **kube_kwargs: Optional extra keyword arguments to pass to the Kubernetes API.\n\n    Returns:\n        A `V1Service` representing the new service.\n\n    Example:\n        ```python\n        from prefect import flow\n        from prefect_kubernetes.credentials import KubernetesCredentials\n        from prefect_kubernetes.services import replace_namespaced_service\n        from kubernetes.client.models import V1Service\n\n        @flow\n        def kubernetes_orchestrator():\n            replace_namespaced_service(\n                kubernetes_credentials=KubernetesCredentials.load(\"k8s-creds\"),\n                service_name=\"my-service\",\n                new_service=V1Service(metadata={...}, spec={...}),\n                namespace=\"my-namespace\",\n            )\n        ```\n    \"\"\"\n    with kubernetes_credentials.get_client(\"core\") as core_v1_client:\n\n        return await run_sync_in_worker_thread(\n            core_v1_client.replace_namespaced_service,\n            name=service_name,\n            body=new_service,\n            namespace=namespace,\n            **kube_kwargs,\n        )\n</code></pre>"},{"location":"utilities/","title":"Utilities","text":""},{"location":"utilities/#prefect_kubernetes.utilities","title":"<code>prefect_kubernetes.utilities</code>","text":"<p>Utilities for working with the Python Kubernetes API.</p>"},{"location":"utilities/#prefect_kubernetes.utilities-functions","title":"Functions","text":""},{"location":"utilities/#prefect_kubernetes.utilities.convert_manifest_to_model","title":"<code>convert_manifest_to_model</code>","text":"<p>Recursively converts a <code>dict</code> representation of a Kubernetes resource to the corresponding Python model containing the Python models that compose it, according to the <code>openapi_types</code> on the class retrieved with <code>v1_model_name</code>.</p> <p>If <code>manifest</code> is a path-like object with a <code>.yaml</code> or <code>.yml</code> extension, it will be treated as a path to a Kubernetes resource manifest and loaded into a <code>dict</code>.</p> <p>Parameters:</p> Name Type Description Default <code>manifest</code> <code>Union[Path, str, KubernetesManifest]</code> <p>A path to a Kubernetes resource manifest or its <code>dict</code> representation.</p> required <code>v1_model_name</code> <code>str</code> <p>The name of a Kubernetes client model to convert the manifest to.</p> required <p>Returns:</p> Type Description <code>V1KubernetesModel</code> <p>A populated instance of a Kubernetes client model with type <code>v1_model_name</code>.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>v1_model_name</code> is not a valid Kubernetes client model name.</p> <code>ValueError</code> <p>If <code>manifest</code> is path-like and is not a valid yaml filename.</p> Source code in <code>prefect_kubernetes/utilities.py</code> <pre><code>def convert_manifest_to_model(\n    manifest: Union[Path, str, KubernetesManifest], v1_model_name: str\n) -&gt; V1KubernetesModel:\n\"\"\"Recursively converts a `dict` representation of a Kubernetes resource to the\n    corresponding Python model containing the Python models that compose it,\n    according to the `openapi_types` on the class retrieved with `v1_model_name`.\n\n    If `manifest` is a path-like object with a `.yaml` or `.yml` extension, it will be\n    treated as a path to a Kubernetes resource manifest and loaded into a `dict`.\n\n    Args:\n        manifest: A path to a Kubernetes resource manifest or its `dict` representation.\n        v1_model_name: The name of a Kubernetes client model to convert the manifest to.\n\n    Returns:\n        A populated instance of a Kubernetes client model with type `v1_model_name`.\n\n    Raises:\n        ValueError: If `v1_model_name` is not a valid Kubernetes client model name.\n        ValueError: If `manifest` is path-like and is not a valid yaml filename.\n    \"\"\"\n    if not manifest:\n        return None\n\n    if not (isinstance(v1_model_name, str) and v1_model_name in set(dir(k8s_models))):\n        raise ValueError(\n            \"`v1_model` must be the name of a valid Kubernetes client model, received \"\n            f\": {v1_model_name!r}\"\n        )\n\n    if isinstance(manifest, (Path, str)):\n        str_path = str(manifest)\n        if not str_path.endswith((\".yaml\", \".yml\")):\n            raise ValueError(\"Manifest must be a valid dict or path to a .yaml file.\")\n        manifest = KubernetesJob.job_from_file(manifest)\n\n    converted_manifest = {}\n    v1_model = getattr(k8s_models, v1_model_name)\n    valid_supplied_fields = (  # valid and specified fields for current `v1_model_name`\n        (k, v)\n        for k, v in v1_model.openapi_types.items()\n        if v1_model.attribute_map[k] in manifest  # map goes \ud83d\udc0d -&gt; \ud83d\udc2b, user supplies \ud83d\udc2b\n    )\n\n    for field, value_type in valid_supplied_fields:\n        if value_type.startswith(\"V1\"):  # field value is another model\n            converted_manifest[field] = convert_manifest_to_model(\n                manifest[v1_model.attribute_map[field]], value_type\n            )\n        elif value_type.startswith(\"list[V1\"):  # field value is a list of models\n            field_item_type = value_type.replace(\"list[\", \"\").replace(\"]\", \"\")\n            try:\n                converted_manifest[field] = [\n                    convert_manifest_to_model(item, field_item_type)\n                    for item in manifest[v1_model.attribute_map[field]]\n                ]\n            except TypeError:\n                converted_manifest[field] = manifest[v1_model.attribute_map[field]]\n        elif value_type in base_types:  # field value is a primitive Python type\n            converted_manifest[field] = manifest[v1_model.attribute_map[field]]\n\n    return v1_model(**converted_manifest)\n</code></pre>"},{"location":"worker/","title":"Worker","text":""},{"location":"worker/#prefect_kubernetes.worker","title":"<code>prefect_kubernetes.worker</code>","text":"<p>Module containing the Kubernetes worker used for executing flow runs as Kubernetes jobs.</p> <p>Note this module is in beta. The interfaces within may change without notice.</p> <p>To start a Kubernetes worker, run the following command:</p> <pre><code>prefect worker start --pool 'my-work-pool' --type kubernetes\n</code></pre> <p>Replace <code>my-work-pool</code> with the name of the work pool you want the worker to poll for flow runs.</p> <p>Using a custom Kubernetes job manifest template</p> <p>The default template used for Kubernetes job manifests looks like this: <pre><code>---\napiVersion: batch/v1\nkind: Job\nmetadata:\nlabels: \"{{ labels }}\"\nnamespace: \"{{ namespace }}\"\ngenerateName: \"{{ name }}-\"\nspec:\nttlSecondsAfterFinished: \"{{ finished_job_ttl }}\"\ntemplate:\nspec:\nparallelism: 1\ncompletions: 1\nrestartPolicy: Never\nserviceAccountName: \"{{ service_account_name }}\"\ncontainers:\n- name: prefect-job\nenv: \"{{ env }}\"\nimage: \"{{ image }}\"\nimagePullPolicy: \"{{ image_pull_policy }}\"\nargs: \"{{ command }}\"\n</code></pre></p> <p>Each values enclosed in <code>{{ }}</code> is a placeholder that will be replaced with a value at runtime. The values that can be used a placeholders are defined by the <code>variables</code> schema defined in the base job template.</p> <p>The default job manifest and available variables can be customized on a work pool by work pool basis. These customizations can be made via the Prefect UI when creating or editing a work pool.</p> <p>For example, if you wanted to allow custom memory requests for a Kubernetes work pool you could update the job manifest template to look like this:</p> <pre><code>---\napiVersion: batch/v1\nkind: Job\nmetadata:\nlabels: \"{{ labels }}\"\nnamespace: \"{{ namespace }}\"\ngenerateName: \"{{ name }}-\"\nspec:\nttlSecondsAfterFinished: \"{{ finished_job_ttl }}\"\ntemplate:\nspec:\nparallelism: 1\ncompletions: 1\nrestartPolicy: Never\nserviceAccountName: \"{{ service_account_name }}\"\ncontainers:\n- name: prefect-job\nenv: \"{{ env }}\"\nimage: \"{{ image }}\"\nimagePullPolicy: \"{{ image_pull_policy }}\"\nargs: \"{{ command }}\"\nresources:\nrequests:\nmemory: \"{{ memory }}Mi\"\nlimits:\nmemory: 128Mi\n</code></pre> <p>In this new template, the <code>memory</code> placeholder allows customization of the memory allocated to Kubernetes jobs created by workers in this work pool, but the limit is hard-coded and cannot be changed by deployments.</p> <p>For more information about work pools and workers, checkout out the Prefect docs.</p>"},{"location":"worker/#prefect_kubernetes.worker-classes","title":"Classes","text":""},{"location":"worker/#prefect_kubernetes.worker.KubernetesImagePullPolicy","title":"<code>KubernetesImagePullPolicy</code>","text":"<p>         Bases: <code>enum.Enum</code></p> <p>Enum representing the image pull policy options for a Kubernetes job.</p> Source code in <code>prefect_kubernetes/worker.py</code> <pre><code>class KubernetesImagePullPolicy(enum.Enum):\n\"\"\"Enum representing the image pull policy options for a Kubernetes job.\"\"\"\n\n    IF_NOT_PRESENT = \"IfNotPresent\"\n    ALWAYS = \"Always\"\n    NEVER = \"Never\"\n</code></pre>"},{"location":"worker/#prefect_kubernetes.worker.KubernetesWorker","title":"<code>KubernetesWorker</code>","text":"<p>         Bases: <code>BaseWorker</code></p> <p>Prefect worker that executes flow runs within Kubernetes Jobs.</p> Source code in <code>prefect_kubernetes/worker.py</code> <pre><code>class KubernetesWorker(BaseWorker):\n\"\"\"Prefect worker that executes flow runs within Kubernetes Jobs.\"\"\"\n\n    type = \"kubernetes\"\n    job_configuration = KubernetesWorkerJobConfiguration\n    job_configuration_variables = KubernetesWorkerVariables\n    _description = (\n        \"Execute flow runs within jobs scheduled on a Kubernetes cluster. Requires a \"\n        \"Kubernetes cluster.\"\n    )\n    _display_name = \"Kubernetes\"\n    _documentation_url = \"https://prefecthq.github.io/prefect-kubernetes/worker/\"\n    _is_beta = True\n    _logo_url = \"https://images.ctfassets.net/gm98wzqotmnx/1zrSeY8DZ1MJZs2BAyyyGk/20445025358491b8b72600b8f996125b/Kubernetes_logo_without_workmark.svg.png?h=250\"  # noqa\n\n    async def run(\n        self,\n        flow_run: \"FlowRun\",\n        configuration: KubernetesWorkerJobConfiguration,\n        task_status: Optional[anyio.abc.TaskStatus] = None,\n    ) -&gt; KubernetesWorkerResult:\n\"\"\"\n        Executes a flow run within a Kubernetes Job and waits for the flow run\n        to complete.\n\n        Args:\n            flow_run: The flow run to execute\n            configuration: The configuration to use when executing the flow run.\n            task_status: The task status object for the current flow run. If provided,\n                the task will be marked as started.\n\n        Returns:\n            KubernetesWorkerResult: A result object containing information about the\n                final state of the flow run\n        \"\"\"\n        logger = self.get_flow_run_logger(flow_run)\n\n        with self._get_configured_kubernetes_client(configuration) as client:\n            logger.info(\"Creating Kubernetes job...\")\n            job = await run_sync_in_worker_thread(\n                self._create_job, configuration, client\n            )\n            pid = await run_sync_in_worker_thread(\n                self._get_infrastructure_pid, job, client\n            )\n            # Indicate that the job has started\n            if task_status is not None:\n                task_status.started(pid)\n\n            # Monitor the job until completion\n\n            events_replicator = KubernetesEventsReplicator(\n                client=client,\n                job_name=job.metadata.name,\n                namespace=configuration.namespace,\n                worker_resource=self._event_resource(),\n                related_resources=self._event_related_resources(\n                    configuration=configuration\n                ),\n                timeout_seconds=configuration.pod_watch_timeout_seconds,\n            )\n\n            with events_replicator:\n                status_code = await run_sync_in_worker_thread(\n                    self._watch_job, logger, job.metadata.name, configuration, client\n                )\n            return KubernetesWorkerResult(identifier=pid, status_code=status_code)\n\n    async def kill_infrastructure(\n        self,\n        infrastructure_pid: str,\n        configuration: KubernetesWorkerJobConfiguration,\n        grace_seconds: int = 30,\n    ):\n\"\"\"\n        Stops a job for a cancelled flow run based on the provided infrastructure PID\n        and run configuration.\n        \"\"\"\n        await run_sync_in_worker_thread(\n            self._stop_job, infrastructure_pid, configuration, grace_seconds\n        )\n\n    def _stop_job(\n        self,\n        infrastructure_pid: str,\n        configuration: KubernetesWorkerJobConfiguration,\n        grace_seconds: int = 30,\n    ):\n        client = self._get_configured_kubernetes_client(configuration)\n        job_cluster_uid, job_namespace, job_name = self._parse_infrastructure_pid(\n            infrastructure_pid\n        )\n\n        if job_namespace != configuration.namespace:\n            raise InfrastructureNotAvailable(\n                f\"Unable to kill job {job_name!r}: The job is running in namespace \"\n                f\"{job_namespace!r} but this worker expected jobs to be running in \"\n                f\"namespace {configuration.namespace!r} based on the work pool and \"\n                \"deployment configuration.\"\n            )\n\n        current_cluster_uid = self._get_cluster_uid(client)\n        if job_cluster_uid != current_cluster_uid:\n            raise InfrastructureNotAvailable(\n                f\"Unable to kill job {job_name!r}: The job is running on another \"\n                \"cluster than the one specified by the infrastructure PID.\"\n            )\n\n        with self._get_batch_client(client) as batch_client:\n            try:\n                batch_client.delete_namespaced_job(\n                    name=job_name,\n                    namespace=job_namespace,\n                    grace_period_seconds=grace_seconds,\n                    # Foreground propagation deletes dependent objects before deleting\n                    # owner objects. This ensures that the pods are cleaned up before\n                    # the job is marked as deleted.\n                    # See: https://kubernetes.io/docs/concepts/architecture/garbage-collection/#foreground-deletion # noqa\n                    propagation_policy=\"Foreground\",\n                )\n            except kubernetes.client.exceptions.ApiException as exc:\n                if exc.status == 404:\n                    raise InfrastructureNotFound(\n                        f\"Unable to kill job {job_name!r}: The job was not found.\"\n                    ) from exc\n                else:\n                    raise\n\n    def _get_configured_kubernetes_client(\n        self, configuration: KubernetesWorkerJobConfiguration\n    ) -&gt; \"ApiClient\":\n\"\"\"\n        Returns a configured Kubernetes client.\n        \"\"\"\n\n        # if a hard-coded cluster config is provided, use it\n        if configuration.cluster_config:\n            return kubernetes.config.new_client_from_config_dict(\n                config_dict=configuration.cluster_config.config,\n                context=configuration.cluster_config.context_name,\n            )\n        else:\n            # If no hard-coded config specified, try to load Kubernetes configuration\n            # within a cluster. If that doesn't work, try to load the configuration\n            # from the local environment, allowing any further ConfigExceptions to\n            # bubble up.\n            try:\n                kubernetes.config.load_incluster_config()\n                config = kubernetes.client.Configuration.get_default_copy()\n                return kubernetes.client.ApiClient(configuration=config)\n            except kubernetes.config.ConfigException:\n                return kubernetes.config.new_client_from_config()\n\n    def _create_job(\n        self, configuration: KubernetesWorkerJobConfiguration, client: \"ApiClient\"\n    ) -&gt; \"V1Job\":\n\"\"\"\n        Creates a Kubernetes job from a job manifest.\n        \"\"\"\n        try:\n            with self._get_batch_client(client) as batch_client:\n                job = batch_client.create_namespaced_job(\n                    configuration.namespace, configuration.job_manifest\n                )\n        except kubernetes.client.exceptions.ApiException as exc:\n            # Parse the reason and message from the response if feasible\n            message = \"\"\n            if exc.reason:\n                message += \": \" + exc.reason\n            if exc.body and \"message\" in exc.body:\n                message += \": \" + exc.body[\"message\"]\n\n            raise InfrastructureError(\n                f\"Unable to create Kubernetes job{message}\"\n            ) from exc\n\n        return job\n\n    @contextmanager\n    def _get_batch_client(\n        self, client: \"ApiClient\"\n    ) -&gt; Generator[\"BatchV1Api\", None, None]:\n\"\"\"\n        Context manager for retrieving a Kubernetes batch client.\n        \"\"\"\n        try:\n            yield kubernetes.client.BatchV1Api(api_client=client)\n        finally:\n            client.rest_client.pool_manager.clear()\n\n    def _get_infrastructure_pid(self, job: \"V1Job\", client: \"ApiClient\") -&gt; str:\n\"\"\"\n        Generates a Kubernetes infrastructure PID.\n\n        The PID is in the format: \"&lt;cluster uid&gt;:&lt;namespace&gt;:&lt;job name&gt;\".\n        \"\"\"\n        cluster_uid = self._get_cluster_uid(client)\n        pid = f\"{cluster_uid}:{job.metadata.namespace}:{job.metadata.name}\"\n        return pid\n\n    def _parse_infrastructure_pid(\n        self, infrastructure_pid: str\n    ) -&gt; Tuple[str, str, str]:\n\"\"\"\n        Parse a Kubernetes infrastructure PID into its component parts.\n\n        Returns a cluster UID, namespace, and job name.\n        \"\"\"\n        cluster_uid, namespace, job_name = infrastructure_pid.split(\":\", 2)\n        return cluster_uid, namespace, job_name\n\n    @contextmanager\n    def _get_core_client(\n        self, client: \"ApiClient\"\n    ) -&gt; Generator[\"CoreV1Api\", None, None]:\n\"\"\"\n        Context manager for retrieving a Kubernetes core client.\n        \"\"\"\n        try:\n            yield kubernetes.client.CoreV1Api(api_client=client)\n        finally:\n            client.rest_client.pool_manager.clear()\n\n    def _get_cluster_uid(self, client: \"ApiClient\") -&gt; str:\n\"\"\"\n        Gets a unique id for the current cluster being used.\n\n        There is no real unique identifier for a cluster. However, the `kube-system`\n        namespace is immutable and has a persistence UID that we use instead.\n\n        PREFECT_KUBERNETES_CLUSTER_UID can be set in cases where the `kube-system`\n        namespace cannot be read e.g. when a cluster role cannot be created. If set,\n        this variable will be used and we will not attempt to read the `kube-system`\n        namespace.\n\n        See https://github.com/kubernetes/kubernetes/issues/44954\n        \"\"\"\n        # Default to an environment variable\n        env_cluster_uid = os.environ.get(\"PREFECT_KUBERNETES_CLUSTER_UID\")\n        if env_cluster_uid:\n            return env_cluster_uid\n\n        # Read the UID from the cluster namespace\n        with self._get_core_client(client) as core_client:\n            namespace = core_client.read_namespace(\"kube-system\")\n        cluster_uid = namespace.metadata.uid\n\n        return cluster_uid\n\n    def _watch_job(\n        self,\n        logger: logging.Logger,\n        job_name: str,\n        configuration: KubernetesWorkerJobConfiguration,\n        client: \"ApiClient\",\n    ) -&gt; int:\n\"\"\"\n        Watch a job.\n\n        Return the final status code of the first container.\n        \"\"\"\n        logger.debug(f\"Job {job_name!r}: Monitoring job...\")\n\n        job = self._get_job(logger, job_name, configuration, client)\n        if not job:\n            return -1\n\n        pod = self._get_job_pod(logger, job_name, configuration, client)\n        if not pod:\n            return -1\n\n        # Calculate the deadline before streaming output\n        deadline = (\n            (time.monotonic() + configuration.job_watch_timeout_seconds)\n            if configuration.job_watch_timeout_seconds is not None\n            else None\n        )\n\n        if configuration.stream_output:\n            with self._get_core_client(client) as core_client:\n                logs = core_client.read_namespaced_pod_log(\n                    pod.metadata.name,\n                    configuration.namespace,\n                    follow=True,\n                    _preload_content=False,\n                    container=\"prefect-job\",\n                )\n                try:\n                    for log in logs.stream():\n                        print(log.decode().rstrip())\n\n                        # Check if we have passed the deadline and should stop streaming\n                        # logs\n                        remaining_time = (\n                            deadline - time.monotonic() if deadline else None\n                        )\n                        if deadline and remaining_time &lt;= 0:\n                            break\n\n                except Exception:\n                    logger.warning(\n                        (\n                            \"Error occurred while streaming logs - \"\n                            \"Job will continue to run but logs will \"\n                            \"no longer be streamed to stdout.\"\n                        ),\n                        exc_info=True,\n                    )\n\n        with self._get_batch_client(client) as batch_client:\n            # Check if the job is completed before beginning a watch\n            job = batch_client.read_namespaced_job(\n                name=job_name, namespace=configuration.namespace\n            )\n            completed = job.status.completion_time is not None\n\n            while not completed:\n                remaining_time = (\n                    math.ceil(deadline - time.monotonic()) if deadline else None\n                )\n                if deadline and remaining_time &lt;= 0:\n                    logger.error(\n                        f\"Job {job_name!r}: Job did not complete within \"\n                        f\"timeout of {configuration.job_watch_timeout_seconds}s.\"\n                    )\n                    return -1\n\n                watch = kubernetes.watch.Watch()\n                # The kubernetes library will disable retries if the timeout kwarg is\n                # present regardless of the value so we do not pass it unless given\n                # https://github.com/kubernetes-client/python/blob/84f5fea2a3e4b161917aa597bf5e5a1d95e24f5a/kubernetes/base/watch/watch.py#LL160\n                timeout_seconds = (\n                    {\"timeout_seconds\": remaining_time} if deadline else {}\n                )\n\n                for event in watch.stream(\n                    func=batch_client.list_namespaced_job,\n                    field_selector=f\"metadata.name={job_name}\",\n                    namespace=configuration.namespace,\n                    **timeout_seconds,\n                ):\n                    if event[\"type\"] == \"DELETED\":\n                        logger.error(f\"Job {job_name!r}: Job has been deleted.\")\n                        completed = True\n                    elif event[\"object\"].status.completion_time:\n                        if not event[\"object\"].status.succeeded:\n                            # Job failed, exit while loop and return pod exit code\n                            logger.error(f\"Job {job_name!r}: Job failed.\")\n                        completed = True\n                    # Check if the job has reached its backoff limit\n                    # and stop watching if it has\n                    elif (\n                        event[\"object\"].spec.backoff_limit is not None\n                        and event[\"object\"].status.failed is not None\n                        and event[\"object\"].status.failed\n                        &gt; event[\"object\"].spec.backoff_limit\n                    ):\n                        logger.error(f\"Job {job_name!r}: Job reached backoff limit.\")\n                        completed = True\n                    # If the job has no backoff limit, check if it has failed\n                    # and stop watching if it has\n                    elif (\n                        not event[\"object\"].spec.backoff_limit\n                        and event[\"object\"].status.failed\n                    ):\n                        completed = True\n\n                    if completed:\n                        watch.stop()\n                        break\n\n        with self._get_core_client(client) as core_client:\n            # Get all pods for the job\n            pods = core_client.list_namespaced_pod(\n                namespace=configuration.namespace, label_selector=f\"job-name={job_name}\"\n            )\n            # Get the status for only the most recently used pod\n            pods.items.sort(\n                key=lambda pod: pod.metadata.creation_timestamp, reverse=True\n            )\n            most_recent_pod = pods.items[0] if pods.items else None\n            first_container_status = (\n                most_recent_pod.status.container_statuses[0]\n                if most_recent_pod\n                else None\n            )\n            if not first_container_status:\n                logger.error(f\"Job {job_name!r}: No pods found for job.\")\n                return -1\n\n        return first_container_status.state.terminated.exit_code\n\n    def _get_job(\n        self,\n        logger: logging.Logger,\n        job_id: str,\n        configuration: KubernetesWorkerJobConfiguration,\n        client: \"ApiClient\",\n    ) -&gt; Optional[\"V1Job\"]:\n\"\"\"Get a Kubernetes job by id.\"\"\"\n        with self._get_batch_client(client) as batch_client:\n            try:\n                job = batch_client.read_namespaced_job(\n                    name=job_id, namespace=configuration.namespace\n                )\n            except kubernetes.client.exceptions.ApiException:\n                logger.error(f\"Job {job_id!r} was removed.\", exc_info=True)\n                return None\n            return job\n\n    def _get_job_pod(\n        self,\n        logger: logging.Logger,\n        job_name: str,\n        configuration: KubernetesWorkerJobConfiguration,\n        client: \"ApiClient\",\n    ) -&gt; Optional[\"V1Pod\"]:\n\"\"\"Get the first running pod for a job.\"\"\"\n        watch = kubernetes.watch.Watch()\n        logger.debug(f\"Job {job_name!r}: Starting watch for pod start...\")\n        last_phase = None\n        with self._get_core_client(client) as core_client:\n            for event in watch.stream(\n                func=core_client.list_namespaced_pod,\n                namespace=configuration.namespace,\n                label_selector=f\"job-name={job_name}\",\n                timeout_seconds=configuration.pod_watch_timeout_seconds,\n            ):\n                phase = event[\"object\"].status.phase\n                if phase != last_phase:\n                    logger.info(f\"Job {job_name!r}: Pod has status {phase!r}.\")\n\n                if phase != \"Pending\":\n                    watch.stop()\n                    return event[\"object\"]\n\n                last_phase = phase\n\n        logger.error(f\"Job {job_name!r}: Pod never started.\")\n</code></pre>"},{"location":"worker/#prefect_kubernetes.worker.KubernetesWorker-functions","title":"Functions","text":""},{"location":"worker/#prefect_kubernetes.worker.KubernetesWorker.kill_infrastructure","title":"<code>kill_infrastructure</code>  <code>async</code>","text":"<p>Stops a job for a cancelled flow run based on the provided infrastructure PID and run configuration.</p> Source code in <code>prefect_kubernetes/worker.py</code> <pre><code>async def kill_infrastructure(\n    self,\n    infrastructure_pid: str,\n    configuration: KubernetesWorkerJobConfiguration,\n    grace_seconds: int = 30,\n):\n\"\"\"\n    Stops a job for a cancelled flow run based on the provided infrastructure PID\n    and run configuration.\n    \"\"\"\n    await run_sync_in_worker_thread(\n        self._stop_job, infrastructure_pid, configuration, grace_seconds\n    )\n</code></pre>"},{"location":"worker/#prefect_kubernetes.worker.KubernetesWorker.run","title":"<code>run</code>  <code>async</code>","text":"<p>Executes a flow run within a Kubernetes Job and waits for the flow run to complete.</p> <p>Parameters:</p> Name Type Description Default <code>flow_run</code> <code>FlowRun</code> <p>The flow run to execute</p> required <code>configuration</code> <code>KubernetesWorkerJobConfiguration</code> <p>The configuration to use when executing the flow run.</p> required <code>task_status</code> <code>Optional[anyio.abc.TaskStatus]</code> <p>The task status object for the current flow run. If provided, the task will be marked as started.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>KubernetesWorkerResult</code> <code>KubernetesWorkerResult</code> <p>A result object containing information about the final state of the flow run</p> Source code in <code>prefect_kubernetes/worker.py</code> <pre><code>async def run(\n    self,\n    flow_run: \"FlowRun\",\n    configuration: KubernetesWorkerJobConfiguration,\n    task_status: Optional[anyio.abc.TaskStatus] = None,\n) -&gt; KubernetesWorkerResult:\n\"\"\"\n    Executes a flow run within a Kubernetes Job and waits for the flow run\n    to complete.\n\n    Args:\n        flow_run: The flow run to execute\n        configuration: The configuration to use when executing the flow run.\n        task_status: The task status object for the current flow run. If provided,\n            the task will be marked as started.\n\n    Returns:\n        KubernetesWorkerResult: A result object containing information about the\n            final state of the flow run\n    \"\"\"\n    logger = self.get_flow_run_logger(flow_run)\n\n    with self._get_configured_kubernetes_client(configuration) as client:\n        logger.info(\"Creating Kubernetes job...\")\n        job = await run_sync_in_worker_thread(\n            self._create_job, configuration, client\n        )\n        pid = await run_sync_in_worker_thread(\n            self._get_infrastructure_pid, job, client\n        )\n        # Indicate that the job has started\n        if task_status is not None:\n            task_status.started(pid)\n\n        # Monitor the job until completion\n\n        events_replicator = KubernetesEventsReplicator(\n            client=client,\n            job_name=job.metadata.name,\n            namespace=configuration.namespace,\n            worker_resource=self._event_resource(),\n            related_resources=self._event_related_resources(\n                configuration=configuration\n            ),\n            timeout_seconds=configuration.pod_watch_timeout_seconds,\n        )\n\n        with events_replicator:\n            status_code = await run_sync_in_worker_thread(\n                self._watch_job, logger, job.metadata.name, configuration, client\n            )\n        return KubernetesWorkerResult(identifier=pid, status_code=status_code)\n</code></pre>"},{"location":"worker/#prefect_kubernetes.worker.KubernetesWorkerJobConfiguration","title":"<code>KubernetesWorkerJobConfiguration</code>","text":"<p>         Bases: <code>BaseJobConfiguration</code></p> <p>Configuration class used by the Kubernetes worker.</p> <p>An instance of this class is passed to the Kubernetes worker's <code>run</code> method for each flow run. It contains all of the information necessary to execute the flow run as a Kubernetes job.</p> <p>Attributes:</p> Name Type Description <code>name</code> <p>The name to give to created Kubernetes job.</p> <code>command</code> <p>The command executed in created Kubernetes jobs to kick off flow run execution.</p> <code>env</code> <p>The environment variables to set in created Kubernetes jobs.</p> <code>labels</code> <p>The labels to set on created Kubernetes jobs.</p> <code>namespace</code> <code>str</code> <p>The Kubernetes namespace to create Kubernetes jobs in.</p> <code>job_manifest</code> <code>Dict[str, Any]</code> <p>The Kubernetes job manifest to use to create Kubernetes jobs.</p> <code>cluster_config</code> <code>Optional[KubernetesClusterConfig]</code> <p>The Kubernetes cluster configuration to use for authentication to a Kubernetes cluster.</p> <code>job_watch_timeout_seconds</code> <code>Optional[int]</code> <p>The number of seconds to wait for the job to complete before timing out. If <code>None</code>, the worker will wait indefinitely.</p> <code>pod_watch_timeout_seconds</code> <code>int</code> <p>The number of seconds to wait for the pod to complete before timing out.</p> <code>stream_output</code> <code>bool</code> <p>Whether or not to stream the job's output.</p> Source code in <code>prefect_kubernetes/worker.py</code> <pre><code>class KubernetesWorkerJobConfiguration(BaseJobConfiguration):\n\"\"\"\n    Configuration class used by the Kubernetes worker.\n\n    An instance of this class is passed to the Kubernetes worker's `run` method\n    for each flow run. It contains all of the information necessary to execute\n    the flow run as a Kubernetes job.\n\n    Attributes:\n        name: The name to give to created Kubernetes job.\n        command: The command executed in created Kubernetes jobs to kick off\n            flow run execution.\n        env: The environment variables to set in created Kubernetes jobs.\n        labels: The labels to set on created Kubernetes jobs.\n        namespace: The Kubernetes namespace to create Kubernetes jobs in.\n        job_manifest: The Kubernetes job manifest to use to create Kubernetes jobs.\n        cluster_config: The Kubernetes cluster configuration to use for authentication\n            to a Kubernetes cluster.\n        job_watch_timeout_seconds: The number of seconds to wait for the job to\n            complete before timing out. If `None`, the worker will wait indefinitely.\n        pod_watch_timeout_seconds: The number of seconds to wait for the pod to\n            complete before timing out.\n        stream_output: Whether or not to stream the job's output.\n    \"\"\"\n\n    namespace: str = Field(default=\"default\")\n    job_manifest: Dict[str, Any] = Field(template=_get_default_job_manifest_template())\n    cluster_config: Optional[KubernetesClusterConfig] = Field(default=None)\n    job_watch_timeout_seconds: Optional[int] = Field(default=None)\n    pod_watch_timeout_seconds: int = Field(default=60)\n    stream_output: bool = Field(default=True)\n\n    # internal-use only\n    _api_dns_name: Optional[str] = None  # Replaces 'localhost' in API URL\n\n    @validator(\"job_manifest\")\n    def _ensure_metadata_is_present(cls, value: Dict[str, Any]):\n\"\"\"Ensures that the metadata is present in the job manifest.\"\"\"\n        if \"metadata\" not in value:\n            value[\"metadata\"] = {}\n        return value\n\n    @validator(\"job_manifest\")\n    def _ensure_labels_is_present(cls, value: Dict[str, Any]):\n\"\"\"Ensures that the metadata is present in the job manifest.\"\"\"\n        if \"labels\" not in value[\"metadata\"]:\n            value[\"metadata\"][\"labels\"] = {}\n        return value\n\n    @validator(\"job_manifest\")\n    def _ensure_namespace_is_present(cls, value: Dict[str, Any], values):\n\"\"\"Ensures that the namespace is present in the job manifest.\"\"\"\n        if \"namespace\" not in value[\"metadata\"]:\n            value[\"metadata\"][\"namespace\"] = values[\"namespace\"]\n        return value\n\n    @validator(\"job_manifest\")\n    def _ensure_job_includes_all_required_components(cls, value: Dict[str, Any]):\n\"\"\"\n        Ensures that the job manifest includes all required components.\n        \"\"\"\n        patch = JsonPatch.from_diff(value, _get_base_job_manifest())\n        missing_paths = sorted([op[\"path\"] for op in patch if op[\"op\"] == \"add\"])\n        if missing_paths:\n            raise ValueError(\n                \"Job is missing required attributes at the following paths: \"\n                f\"{', '.join(missing_paths)}\"\n            )\n        return value\n\n    @validator(\"job_manifest\")\n    def _ensure_job_has_compatible_values(cls, value: Dict[str, Any]):\n        patch = JsonPatch.from_diff(value, _get_base_job_manifest())\n        incompatible = sorted(\n            [\n                f\"{op['path']} must have value {op['value']!r}\"\n                for op in patch\n                if op[\"op\"] == \"replace\"\n            ]\n        )\n        if incompatible:\n            raise ValueError(\n                \"Job has incompatible values for the following attributes: \"\n                f\"{', '.join(incompatible)}\"\n            )\n        return value\n\n    def prepare_for_flow_run(\n        self,\n        flow_run: \"FlowRun\",\n        deployment: Optional[\"DeploymentResponse\"] = None,\n        flow: Optional[\"Flow\"] = None,\n    ):\n\"\"\"\n        Prepares the job configuration for a flow run.\n\n        Ensures that necessary values are present in the job manifest and that the\n        job manifest is valid.\n\n        Args:\n            flow_run: The flow run to prepare the job configuration for\n            deployment: The deployment associated with the flow run used for\n                preparation.\n            flow: The flow associated with the flow run used for preparation.\n        \"\"\"\n        super().prepare_for_flow_run(flow_run, deployment, flow)\n        # Update configuration env and job manifest env\n        self._update_prefect_api_url_if_local_server()\n        self.job_manifest[\"spec\"][\"template\"][\"spec\"][\"containers\"][0][\"env\"] = [\n            {\"name\": k, \"value\": v} for k, v in self.env.items()\n        ]\n        # Update labels in job manifest\n        self._slugify_labels()\n        # Add defaults to job manifest if necessary\n        self._populate_image_if_not_present()\n        self._populate_command_if_not_present()\n        self._populate_generate_name_if_not_present()\n\n    def _update_prefect_api_url_if_local_server(self):\n\"\"\"If the API URL has been set by the base environment rather than the by the\n        user, update the value to ensure connectivity when using a bridge network by\n        updating local connections to use the internal host\n        \"\"\"\n        if self.env.get(\"PREFECT_API_URL\") and self._api_dns_name:\n            self.env[\"PREFECT_API_URL\"] = (\n                self.env[\"PREFECT_API_URL\"]\n                .replace(\"localhost\", self._api_dns_name)\n                .replace(\"127.0.0.1\", self._api_dns_name)\n            )\n\n    def _slugify_labels(self):\n\"\"\"Slugifies the labels in the job manifest.\"\"\"\n        all_labels = {**self.job_manifest[\"metadata\"].get(\"labels\", {}), **self.labels}\n        self.job_manifest[\"metadata\"][\"labels\"] = {\n            _slugify_label_key(k): _slugify_label_value(v)\n            for k, v in all_labels.items()\n        }\n\n    def _populate_image_if_not_present(self):\n\"\"\"Ensures that the image is present in the job manifest. Populates the image\n        with the default Prefect image if it is not present.\"\"\"\n        try:\n            if (\n                \"image\"\n                not in self.job_manifest[\"spec\"][\"template\"][\"spec\"][\"containers\"][0]\n            ):\n                self.job_manifest[\"spec\"][\"template\"][\"spec\"][\"containers\"][0][\n                    \"image\"\n                ] = get_prefect_image_name()\n        except KeyError:\n            raise ValueError(\n                \"Unable to verify image due to invalid job manifest template.\"\n            )\n\n    def _populate_command_if_not_present(self):\n\"\"\"\n        Ensures that the command is present in the job manifest. Populates the command\n        with the `prefect -m prefect.engine` if a command is not present.\n        \"\"\"\n        try:\n            command = self.job_manifest[\"spec\"][\"template\"][\"spec\"][\"containers\"][\n                0\n            ].get(\"args\")\n            if command is None:\n                self.job_manifest[\"spec\"][\"template\"][\"spec\"][\"containers\"][0][\n                    \"args\"\n                ] = [\n                    \"python\",\n                    \"-m\",\n                    \"prefect.engine\",\n                ]\n            elif isinstance(command, str):\n                self.job_manifest[\"spec\"][\"template\"][\"spec\"][\"containers\"][0][\n                    \"args\"\n                ] = command.split()\n            elif not isinstance(command, list):\n                raise ValueError(\n                    \"Invalid job manifest template: 'command' must be a string or list.\"\n                )\n        except KeyError:\n            raise ValueError(\n                \"Unable to verify command due to invalid job manifest template.\"\n            )\n\n    def _populate_generate_name_if_not_present(self):\n\"\"\"Ensures that the generateName is present in the job manifest.\"\"\"\n        manifest_generate_name = self.job_manifest[\"metadata\"].get(\"generateName\", \"\")\n        has_placeholder = len(find_placeholders(manifest_generate_name)) &gt; 0\n        # if name wasn't present during template rendering, generateName will be\n        # just a hyphen\n        manifest_generate_name_templated_with_empty_string = (\n            manifest_generate_name == \"-\"\n        )\n        if (\n            not manifest_generate_name\n            or has_placeholder\n            or manifest_generate_name_templated_with_empty_string\n        ):\n            generate_name = None\n            if self.name:\n                generate_name = _slugify_name(self.name)\n            # _slugify_name will return None if the slugified name in an exception\n            if not generate_name:\n                generate_name = \"prefect-job\"\n            self.job_manifest[\"metadata\"][\"generateName\"] = f\"{generate_name}-\"\n</code></pre>"},{"location":"worker/#prefect_kubernetes.worker.KubernetesWorkerJobConfiguration-functions","title":"Functions","text":""},{"location":"worker/#prefect_kubernetes.worker.KubernetesWorkerJobConfiguration.prepare_for_flow_run","title":"<code>prepare_for_flow_run</code>","text":"<p>Prepares the job configuration for a flow run.</p> <p>Ensures that necessary values are present in the job manifest and that the job manifest is valid.</p> <p>Parameters:</p> Name Type Description Default <code>flow_run</code> <code>FlowRun</code> <p>The flow run to prepare the job configuration for</p> required <code>deployment</code> <code>Optional[DeploymentResponse]</code> <p>The deployment associated with the flow run used for preparation.</p> <code>None</code> <code>flow</code> <code>Optional[Flow]</code> <p>The flow associated with the flow run used for preparation.</p> <code>None</code> Source code in <code>prefect_kubernetes/worker.py</code> <pre><code>def prepare_for_flow_run(\n    self,\n    flow_run: \"FlowRun\",\n    deployment: Optional[\"DeploymentResponse\"] = None,\n    flow: Optional[\"Flow\"] = None,\n):\n\"\"\"\n    Prepares the job configuration for a flow run.\n\n    Ensures that necessary values are present in the job manifest and that the\n    job manifest is valid.\n\n    Args:\n        flow_run: The flow run to prepare the job configuration for\n        deployment: The deployment associated with the flow run used for\n            preparation.\n        flow: The flow associated with the flow run used for preparation.\n    \"\"\"\n    super().prepare_for_flow_run(flow_run, deployment, flow)\n    # Update configuration env and job manifest env\n    self._update_prefect_api_url_if_local_server()\n    self.job_manifest[\"spec\"][\"template\"][\"spec\"][\"containers\"][0][\"env\"] = [\n        {\"name\": k, \"value\": v} for k, v in self.env.items()\n    ]\n    # Update labels in job manifest\n    self._slugify_labels()\n    # Add defaults to job manifest if necessary\n    self._populate_image_if_not_present()\n    self._populate_command_if_not_present()\n    self._populate_generate_name_if_not_present()\n</code></pre>"},{"location":"worker/#prefect_kubernetes.worker.KubernetesWorkerResult","title":"<code>KubernetesWorkerResult</code>","text":"<p>         Bases: <code>BaseWorkerResult</code></p> <p>Contains information about the final state of a completed process</p> Source code in <code>prefect_kubernetes/worker.py</code> <pre><code>class KubernetesWorkerResult(BaseWorkerResult):\n\"\"\"Contains information about the final state of a completed process\"\"\"\n</code></pre>"},{"location":"worker/#prefect_kubernetes.worker.KubernetesWorkerVariables","title":"<code>KubernetesWorkerVariables</code>","text":"<p>         Bases: <code>BaseVariables</code></p> <p>Default variables for the Kubernetes worker.</p> <p>The schema for this class is used to populate the <code>variables</code> section of the default base job template.</p> Source code in <code>prefect_kubernetes/worker.py</code> <pre><code>class KubernetesWorkerVariables(BaseVariables):\n\"\"\"\n    Default variables for the Kubernetes worker.\n\n    The schema for this class is used to populate the `variables` section of the default\n    base job template.\n    \"\"\"\n\n    namespace: str = Field(\n        default=\"default\", description=\"The Kubernetes namespace to create jobs within.\"\n    )\n    image: Optional[str] = Field(\n        default=None,\n        description=\"The image reference of a container image to use for created jobs. \"\n        \"If not set, the latest Prefect image will be used.\",\n        example=\"docker.io/prefecthq/prefect:2-latest\",\n    )\n    service_account_name: Optional[str] = Field(\n        default=None,\n        description=\"The Kubernetes service account to use for job creation.\",\n    )\n    image_pull_policy: Literal[\"IfNotPresent\", \"Always\", \"Never\"] = Field(\n        default=KubernetesImagePullPolicy.IF_NOT_PRESENT,\n        description=\"The Kubernetes image pull policy to use for job containers.\",\n    )\n    finished_job_ttl: Optional[int] = Field(\n        default=None,\n        title=\"Finished Job TTL\",\n        description=\"The number of seconds to retain jobs after completion. If set, \"\n        \"finished jobs will be cleaned up by Kubernetes after the given delay. If not \"\n        \"set, jobs will be retained indefinitely.\",\n    )\n    job_watch_timeout_seconds: Optional[int] = Field(\n        default=None,\n        description=(\n            \"Number of seconds to wait for each event emitted by a job before \"\n            \"timing out. If not set, the worker will wait for each event indefinitely.\"\n        ),\n    )\n    pod_watch_timeout_seconds: int = Field(\n        default=60,\n        description=\"Number of seconds to watch for pod creation before timing out.\",\n    )\n    stream_output: bool = Field(\n        default=True,\n        description=(\n            \"If set, output will be streamed from the job to local standard output.\"\n        ),\n    )\n    cluster_config: Optional[KubernetesClusterConfig] = Field(\n        default=None,\n        description=\"The Kubernetes cluster config to use for job creation.\",\n    )\n</code></pre>"}]}